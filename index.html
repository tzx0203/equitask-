
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" />
<title>Workload Distributor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    /* New Palette definition */
    --c-eggshell: #f4f1de;
    --c-burnt-peach: #e07a5f;
    --c-indigo: #3d405b;
    --c-teal: #81b29a;
    --c-apricot: #f2cc8f;
    --c-white: #ffffff;
    --c-periwinkle: #7b8cde;
    
    /* Functional mapping */
    --bg-body: var(--c-eggshell);
    --text-main: var(--c-indigo);
    --text-muted: rgba(61, 64, 91, 0.65);
    --border: rgba(61, 64, 91, 0.08);
    --card-bg: var(--c-white);
    --input-bg: rgba(61, 64, 91, 0.04);
    --input-focus-bg: #fff;
    
    --primary: var(--c-burnt-peach);
    --success: var(--c-teal);
    --warning: var(--c-apricot);
    --danger: #d95d5d;
    
    --mode-color: var(--c-indigo);
    --radius-sm: 12px;
    --radius-md: 20px;
    --radius-lg: 30px;
    
    /* Minimalist Shadows */
    --shadow-soft: 0 4px 20px -2px rgba(61, 64, 91, 0.06);
    --shadow-hover: 0 10px 25px -5px rgba(61, 64, 91, 0.1);

    /* Badge Colors (Light Mode) */
    --badge-ok-bg: rgba(129, 178, 154, 0.2);
    --badge-ok-text: #2d6a55;
    --badge-warn-bg: rgba(242, 204, 143, 0.3);
    --badge-warn-text: #8f6014;
    --badge-bad-bg: rgba(224, 122, 95, 0.2);
    --badge-bad-text: #a83232;
  }

  [data-theme="dark"] {
    --bg-body: #282a3a;
    --text-main: #f4f1de;
    --text-muted: rgba(244, 241, 222, 0.6);
    --border: rgba(244, 241, 222, 0.1);
    --card-bg: #323548;
    --input-bg: rgba(0, 0, 0, 0.2);
    --input-focus-bg: #3b3e54;
    --primary: #e07a5f;
    --success: #81b29a;
    --warning: #f2cc8f;
    --shadow-soft: 0 10px 30px -10px rgba(0, 0, 0, 0.3);
    --shadow-hover: 0 15px 35px -5px rgba(0, 0, 0, 0.4);
    
    /* Badge Colors (Dark Mode) - Lighter text for contrast */
    --badge-ok-text: #81b29a;
    --badge-warn-text: #f2cc8f;
    --badge-bad-text: #e07a5f;
  }

  /* Distinct Mode Colors */
  body.mode-time { --mode-color: var(--c-burnt-peach); }
  body.mode-revenue { --mode-color: var(--c-teal); }
  body.mode-combined { --mode-color: var(--c-periwinkle); }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-body);
    color: var(--text-main);
    margin: 0; padding: 16px;
    display: flex; justify-content: center;
    min-height: 100vh;
    transition: background-color 0.3s, color 0.3s;
  }

  .app-wrapper { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 20px; }

  /* --- HEADER --- */
  header { display: flex; justify-content: space-between; align-items: center; gap: 8px; padding-bottom: 4px; }
  h1 { font-size: 20px; font-weight: 800; margin: 0; letter-spacing: -0.02em; flex: 1; color: var(--text-main); }
  .header-controls { display: flex; gap: 8px; }

  .icon-btn {
    background: transparent; border: none;
    border-radius: var(--radius-sm); cursor: pointer; color: var(--text-muted);
    padding: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s; height: 38px; width: 38px;
  }
  .icon-btn:hover { background: var(--input-bg); color: var(--text-main); }
  .icon-btn svg { width: 20px; height: 20px; stroke-width: 2; }
  
  #modeBtn { 
    color: var(--mode-color); font-weight: 700; 
    width: auto; padding: 0 14px; gap: 6px; font-size: 12px; 
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    box-shadow: 0 2px 10px rgba(0,0,0,0.03);
  }
  #modeBtn svg { width: 14px; height: 14px; }
  
  /* --- CONFIG --- */
  .config-container {
    background: var(--card-bg); 
    border-radius: var(--radius-md);
    padding: 20px; 
    display: flex; flex-direction: column; gap: 20px;
    box-shadow: var(--shadow-soft);
  }

  .mode-indicator {
    font-size: 10px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;
    color: var(--mode-color); display: flex; align-items: center; gap: 6px;
    margin-bottom: 4px; opacity: 0.9;
  }
  .mode-indicator svg { width: 12px; height: 12px; }

  /* Compact Input Grid */
  .input-strip { 
    display: grid; 
    grid-template-columns: repeat(3, 1fr); 
    gap: 10px; 
    align-items: end;
  }
  @media (min-width: 450px) {
    .input-strip { grid-template-columns: repeat(5, 1fr); }
  }

  .input-group { display: flex; flex-direction: column; gap: 6px; }
  
  .input-group label { 
    font-size: 10px; font-weight: 700; color: var(--text-muted); 
    letter-spacing: 0.03em; text-align: center;
    overflow: hidden; white-space: nowrap; text-overflow: ellipsis; 
  }
  .input-group input {
    width: 100%; padding: 10px 4px; text-align: center; border-radius: var(--radius-sm);
    border: 1px solid transparent; background: var(--input-bg); color: var(--text-main);
    font-size: 15px; font-weight: 700; transition: all 0.2s;
    font-family: inherit; -moz-appearance: textfield;
  }
  .input-group input::-webkit-outer-spin-button,
  .input-group input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  
  .input-group input:focus { 
    outline: none; background: var(--input-focus-bg); 
    border-color: var(--mode-color); 
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); 
  }
  .input-group input::placeholder { color: var(--text-muted); opacity: 0.3; }

  /* Stats & Actions */
  .action-strip {
    display: flex; flex-direction: column; gap: 16px;
    padding-top: 4px;
  }
  
  .stats-area { 
    display: flex; gap: 8px 16px; flex-wrap: wrap; 
    justify-content: center; padding: 4px 0;
  }
  .stat-pill {
    font-size: 11px; color: var(--text-muted); font-weight: 500;
    display: flex; align-items: center; gap: 4px;
  }
  .stat-pill strong { color: var(--text-main); font-weight: 700; }
  
  .btn-area { display: grid; grid-template-columns: auto auto 1fr; gap: 8px; width: 100%; }
  
  button.action-btn {
    cursor: pointer; font-size: 12px; font-weight: 700; padding: 10px 12px;
    border-radius: var(--radius-lg); border: none; transition: all 0.2s;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Inter', sans-serif;
  }
  button.action-btn:active { transform: scale(0.97); }
  
  .btn-reset { background: transparent; color: var(--text-muted); padding: 10px; }
  .btn-reset:hover { background: var(--input-bg); color: var(--danger); }
  
  .btn-save { background: var(--input-bg); color: var(--text-main); }
  .btn-save:hover { background: #e5e6eb; }
  
  .btn-go { background: var(--mode-color); color: white; box-shadow: 0 4px 15px -4px rgba(0,0,0,0.2); }
  .btn-go:hover { opacity: 0.95; box-shadow: 0 6px 20px -4px rgba(0,0,0,0.25); }
  
  .btn-recalc { background: var(--success); color: white; grid-column: 3; }

  /* --- SETTINGS MODAL --- */
  .modal-backdrop {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(61, 64, 91, 0.2); z-index: 100; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
  }
  .modal-backdrop.open { display: flex; }
  .settings-card {
    background: var(--card-bg); width: 90%; max-width: 380px;
    border-radius: var(--radius-md); padding: 24px; border: none;
    box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.15);
    display: flex; flex-direction: column; gap: 20px;
  }
  .settings-header { display: flex; justify-content: space-between; align-items: center; }
  .settings-title { font-size: 18px; font-weight: 800; color: var(--text-main); }
  .close-modal { background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-muted); padding: 0; line-height: 1; }
  
  .setting-section { display: flex; flex-direction: column; gap: 8px; }
  .setting-label { font-size: 10px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.8px; }
  
  .select-box {
    width: 100%; padding: 12px; border-radius: var(--radius-sm); border: 1px solid transparent;
    background: var(--input-bg); color: var(--text-main); font-size: 13px; font-weight: 600;
    outline: none; transition: 0.2s;
  }
  .rate-rows-container { display: flex; flex-direction: column; gap: 8px; }
  .rate-row { display: flex; gap: 8px; align-items: center; }
  .rate-name { 
    flex: 1.5; padding: 10px; border-radius: var(--radius-sm); border: 1px solid transparent; 
    font-size: 13px; font-weight: 600; color: var(--text-main); background: var(--input-bg); min-width: 0; 
  }
  .rate-input-group { flex: 1; display: flex; gap: 4px; align-items: center; min-width: 0; position: relative; }
  .rate-input-group span { position: absolute; right: 8px; font-size: 10px; color: var(--text-muted); font-weight: 600; pointer-events: none; }
  .rate-input { 
    width: 100%; padding: 10px 24px 10px 8px; border-radius: var(--radius-sm); 
    border: 1px solid transparent; font-size: 13px; font-weight: 600; 
    color: var(--text-main); background: var(--input-bg); text-align: center; min-width: 0; 
  }
  .rate-name:focus, .rate-input:focus, .select-box:focus { background: var(--input-focus-bg); border-color: var(--mode-color); }

  .btn-done { background: var(--mode-color); color: white; width: 100%; padding: 14px; border-radius: var(--radius-sm); border: none; font-weight: 700; cursor: pointer; font-size: 13px; margin-top: 8px; }

  /* --- RESULTS --- */
  .results-container { display: flex; flex-direction: column; gap: 24px; padding-bottom: 40px; }
  .split-grid-wrapper { display: flex; flex-direction: column; gap: 12px; }
  .grid-title { 
    font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; 
    letter-spacing: 0.8px; display: flex; align-items: center; gap: 8px;
    padding-bottom: 6px; border-bottom: 1px solid var(--border);
  }
  .grid-title svg { width: 14px; height: 14px; color: var(--mode-color); }
  
  .results-grid { 
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(145px, 1fr)); 
    gap: 10px; width: 100%; 
  }

  .staff-card {
    background: var(--card-bg); border-radius: var(--radius-md); border: none;
    box-shadow: var(--shadow-soft); overflow: hidden;
    display: flex; flex-direction: column; transition: transform 0.2s;
  }
  .staff-card:hover { transform: translateY(-2px); }
  
  .card-border-top { height: 4px; width: 100%; }
  
  .card-header { padding: 8px 10px 0 10px; display: flex; justify-content: space-between; align-items: center; }
  .staff-name { font-size: 10px; font-weight: 800; opacity: 0.9; text-transform: uppercase; letter-spacing: 0.5px; }
  
  .lock-btn {
    background: transparent; border: none; cursor: pointer; 
    color: var(--text-muted); padding: 4px; border-radius: 50%;
    opacity: 0.3; transition: 0.2s;
  }
  .lock-btn:hover { opacity: 1; color: var(--text-main); background: var(--input-bg); }
  .lock-btn svg { width: 14px; height: 14px; }
  .lock-btn.locked { color: var(--mode-color); opacity: 1; background: rgba(0,0,0,0.03); }

  .card-hero { padding: 4px 10px 10px 10px; text-align: left; }
  .hero-main { font-size: 28px; font-weight: 800; color: var(--text-main); letter-spacing: -1px; line-height: 1; display: flex; align-items: baseline; }
  .hero-main span { font-size: 14px; font-weight: 600; color: var(--text-muted); margin-left: 2px; }
  .hero-main span.prefix { margin-right: 2px; margin-left: 0; font-size: 16px; }
  
  .hero-sub { display: flex; align-items: center; gap: 6px; margin-top: 6px; }
  .hero-sec { 
    font-size: 10px; font-weight: 700; color: var(--text-muted); 
    background: var(--input-bg); padding: 3px 8px; border-radius: 12px; 
  }

  .card-tasks { 
    padding: 8px; background: var(--input-bg); flex: 1; 
    display: flex; flex-direction: column; gap: 4px; 
  }
  .task-row { 
    display: flex; align-items: center; justify-content: space-between; 
    background: var(--card-bg); padding: 6px 8px; border-radius: 8px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.01); 
  }
  .task-row.is-zero { display: none; }
  .task-label { font-size: 10px; font-weight: 600; color: var(--text-muted); max-width: 80px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .task-input { width: 40px; border: none; background: transparent; text-align: right; font-size: 12px; font-weight: 700; color: var(--text-main); padding: 0; outline: none; }
  
  .empty-state { text-align: center; width: 100%; color: var(--text-muted); padding: 40px 20px; font-weight: 500; font-size: 13px; opacity: 0.7; }

  /* History */
  .history-section { display: none; flex-direction: column; gap: 16px; }
  .history-section.has-data { display: flex; }
  .history-title { font-size: 12px; font-weight: 800; color: var(--text-main); text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }

  .rec-card { 
    background: var(--card-bg); border-radius: var(--radius-md); 
    padding: 16px; display: flex; flex-direction: column; gap: 12px; 
    box-shadow: var(--shadow-soft);
  }
  .rec-meta { display: flex; justify-content: space-between; align-items: center; }
  .rec-date { font-size: 11px; font-weight: 700; color: var(--text-muted); background: var(--input-bg); padding: 4px 10px; border-radius: 20px; }
  
  .btn-del-rec { 
    border: none; background: transparent; color: var(--danger); 
    cursor: pointer; padding: 4px; opacity: 0.5; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
  }
  .btn-del-rec:hover { opacity: 1; background: var(--input-bg); }
  .btn-del-rec svg { width: 14px; height: 14px; }

  .rec-row-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .rec-row-label { font-size: 10px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
  
  .var-badge { font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 6px; }
  
  .var-badge.ok { background: var(--badge-ok-bg); color: var(--badge-ok-text); }
  .var-badge.warn { background: var(--badge-warn-bg); color: var(--badge-warn-text); }
  .var-badge.bad { background: var(--badge-bad-bg); color: var(--badge-bad-text); }

  .rec-staff-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
  .rec-staff-item { background: var(--input-bg); border-radius: var(--radius-sm); padding: 8px; display: flex; flex-direction: column; gap: 4px; }
  .rsi-name { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; }
  .rsi-stats { display: flex; justify-content: space-between; align-items: center; }
  .rsi-money { font-size: 10px; font-weight: 700; color: var(--success); }
  .rsi-time { font-size: 10px; font-weight: 700; color: var(--text-main); }
  .rsi-tasks { font-size: 9px; color: var(--text-muted); margin-top: 4px; border-top: 1px dashed rgba(0,0,0,0.05); padding-top: 4px; }

  /* Visualization Modal */
  .vis-modal {
    position: fixed; top:0; left:0; width:100%; height:100%;
    background: rgba(244, 241, 222, 0.8); z-index: 200;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
  }
  .vis-modal.open { display: flex; }
  .vis-card {
    background: var(--card-bg); width: 85%; max-width: 300px; padding: 32px 24px;
    border-radius: var(--radius-lg); text-align: center; color: var(--text-main);
    display: flex; flex-direction: column; align-items: center;
    box-shadow: 0 20px 50px rgba(61, 64, 91, 0.15);
  }
  .vis-spinner { 
    width: 36px; height: 36px; 
    border: 3px solid var(--input-bg); border-top-color: var(--mode-color); 
    border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px; 
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .vis-title { font-weight: 800; font-size: 16px; margin-bottom: 12px; }
  .vis-bar-bg { width: 100%; height: 6px; background: var(--input-bg); border-radius: 4px; overflow: hidden; margin-bottom: 12px; width: 100%; }
  .vis-bar-fill { height: 100%; background: var(--mode-color); width: 0%; transition: width 0.2s ease-out; }
  .vis-stat { font-size: 11px; color: var(--text-muted); margin-bottom: 4px; font-weight: 600; }
  .vis-cancel-btn {
      margin-top: 20px; background: transparent; color: var(--danger); border: none;
      padding: 8px 20px; border-radius: 20px; font-weight: 700; font-size: 12px; cursor: pointer;
      transition: all 0.2s;
  }
  .vis-cancel-btn:hover { background: var(--input-bg); }

</style>
</head>
<body class="mode-time">

<div class="app-wrapper">
  
  <header>
    <h1>Workload Distributor</h1>
    <div class="header-controls">
      <button class="icon-btn" onclick="toggleSettings()" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
      </button>
      <button class="icon-btn" onclick="toggleMode()" id="modeBtn" title="Switch Logic">
        <!-- Icon injected JS -->
      </button>
      <button class="icon-btn" onclick="toggleTheme()" id="themeBtn" title="Toggle Theme">
        <!-- Icon Injected by JS -->
      </button>
    </div>
  </header>

  <!-- Config -->
  <div class="config-container">
    <div class="mode-indicator" id="modeLabel">PRIORITY: HOURS</div>

    <div class="input-strip">
      <div class="input-group">
        <label>Staff</label>
        <input id="totalStaff" type="number" min="1" placeholder="4" inputmode="numeric">
      </div>
      <div class="input-group"><label id="lbl_0">Task 1</label><input id="in_0" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_1">Task 2</label><input id="in_1" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_2">Task 3</label><input id="in_2" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_3">Task 4</label><input id="in_3" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
    </div>

    <div class="action-strip">
      <div class="stats-area">
        <div class="stat-pill">Orders: <strong id="valCount">0</strong></div>
        <div class="stat-pill">Time: <strong id="valHours">0h</strong></div>
        <div class="stat-pill">Combos: <strong id="valComplexity">-</strong></div>
      </div>
      <div class="btn-area">
        <button class="action-btn btn-reset" onclick="resetAll()">Reset</button>
        <button class="action-btn btn-save" onclick="saveDualRecord()">Save</button>
        <button id="calcBtn" class="action-btn btn-go" onclick="initialCalculate()">Distribute</button>
        <button id="recalcBtn" class="action-btn btn-recalc" onclick="recalculateUnlocked()" style="display:none;">Recalc</button>
      </div>
    </div>
  </div>

  <!-- Results -->
  <div id="resultsContainer" class="results-container">
    <div class="empty-state">Enter inputs to distribute workload...</div>
  </div>

  <!-- History -->
  <div id="historySection" class="history-section">
    <div class="history-title">Saved Records</div>
    <div id="historyList" style="display:flex; flex-direction:column; gap:12px;"></div>
  </div>

</div>

<!-- Visualization Overlay -->
<div id="visModal" class="vis-modal">
  <div class="vis-card">
    <div class="vis-spinner"></div>
    <div class="vis-title">Optimizing...</div>
    <div class="vis-bar-bg"><div id="visBar" class="vis-bar-fill"></div></div>
    <div id="visStatus" class="vis-stat">Initializing...</div>
    <div id="visBest" class="vis-stat">Best Diff: -</div>
    <button class="vis-cancel-btn" onclick="cancelCalculation()">Cancel</button>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal-backdrop">
  <div class="settings-card">
    <div class="settings-header">
      <div class="settings-title">Settings</div>
      <button class="close-modal" onclick="toggleSettings()">&times;</button>
    </div>

    <div class="setting-section">
      <div class="setting-label">Algorithm Strategy</div>
      <select id="algoSelect" class="select-box" onchange="updateStats()">
        <option value="brute" selected>Force Brute Force (Exact, Slow)</option>
        <option value="auto">Auto (Switch at 150M Combos)</option>
        <option value="genetic">Force Genetic Algo (Approx, Fast)</option>
      </select>
    </div>
    
    <div class="setting-section">
      <div class="setting-label">Task Configuration (Name, Mins, Revenue)</div>
      <div id="ratesPanel" class="rate-rows-container">
        <!-- Injected JS -->
      </div>
    </div>

    <button class="btn-done" onclick="toggleSettings()">Done</button>
  </div>
</div>

<!-- WORKER SCRIPT: Embedded securely to prevent string issues -->
<script id="worker-code" type="javascript/worker">
  self.onmessage = function(e) {
    try {
        const { mode, staffCount, taskConfig, targetMode } = e.data;
        const sCount = Number(staffCount); // Force Number
        
        // --- MODE 1: BRUTE FORCE (Exact) ---
        if (mode === 'brute') {
          const { chunkD0, allD1, allD2, allD3 } = e.data;
          let bestState = null;
          let bestMetric = { diff1: Infinity, diff2: Infinity };
          
          const total = chunkD0.length * allD1.length * allD2.length * allD3.length;
          let processed = 0;
          const reportInterval = Math.max(1000, Math.floor(total / 20));

          for (let d0 of chunkD0) {
            for (let d1 of allD1) {
              for (let d2 of allD2) {
                for (let d3 of allD3) {
                  
                  // Use Float32 for speed and to avoid string concat issues
                  let mins = new Float32Array(sCount);
                  let revs = new Float32Array(sCount);
                  
                  for(let s=0; s<sCount; s++) {
                      // d0[s] is the count assigned to staff 's'
                      mins[s] = d0[s]*taskConfig[0].min + d1[s]*taskConfig[1].min + d2[s]*taskConfig[2].min + d3[s]*taskConfig[3].min;
                      revs[s] = d0[s]*taskConfig[0].val + d1[s]*taskConfig[1].val + d2[s]*taskConfig[2].val + d3[s]*taskConfig[3].val;
                  }

                  let minT = mins[0], maxT = mins[0];
                  let minR = revs[0], maxR = revs[0];
                  for(let s=1; s<sCount; s++){
                      if(mins[s] < minT) minT = mins[s];
                      if(mins[s] > maxT) maxT = mins[s];
                      if(revs[s] < minR) minR = revs[s];
                      if(revs[s] > maxR) maxR = revs[s];
                  }

                  let diffT = maxT - minT;
                  let diffR = maxR - minR;
                  
                  let dPrimary = targetMode === 'time' ? diffT : diffR;
                  let dSecondary = targetMode === 'time' ? diffR : diffT;

                  if (dPrimary < bestMetric.diff1 || (dPrimary === bestMetric.diff1 && dSecondary < bestMetric.diff2)) {
                      bestMetric = { diff1: dPrimary, diff2: dSecondary };
                      bestState = [d0, d1, d2, d3];
                  }

                  processed++;
                  if(processed % reportInterval === 0) self.postMessage({ type: 'progress', val: processed, total: total });
                }
              }
            }
          }
          self.postMessage({ type: 'done', bestState, bestMetric });
        } 
        
        // --- MODE 2: GENETIC ALGORITHM (Approx) ---
        else if (mode === 'genetic') {
           const { flatTasks, seed } = e.data;
           const POP_SIZE = 200;
           const GENERATIONS = 500;
           const ELITISM = 10;
           
           let population = [];
           // Init Population
           for(let i=0; i<POP_SIZE; i++) {
               let genome = new Uint8Array(flatTasks.length);
               for(let j=0; j<flatTasks.length; j++) genome[j] = Math.floor(Math.random() * sCount);
               population.push(genome);
           }
           
           const calcFitness = (genome) => {
               let mins = new Float32Array(sCount);
               let revs = new Float32Array(sCount);
               
               for(let i=0; i<genome.length; i++) {
                   const s = genome[i];
                   const t = flatTasks[i];
                   mins[s] += t.min;
                   revs[s] += t.val;
               }
               
               let minT = mins[0], maxT = mins[0];
               let minR = revs[0], maxR = revs[0];
               for(let s=1; s<sCount; s++) {
                   if(mins[s] < minT) minT = mins[s];
                   if(mins[s] > maxT) maxT = mins[s];
                   if(revs[s] < minR) minR = revs[s];
                   if(revs[s] > maxR) maxR = revs[s];
               }
               
               const diffT = maxT - minT;
               const diffR = maxR - minR;
               const metric = targetMode === 'time' ? diffT : diffR;
               const metric2 = targetMode === 'time' ? diffR : diffT;
               
               return { genome, metric, metric2, mins, revs };
           };

           for(let g=0; g<GENERATIONS; g++) {
               let scored = population.map(calcFitness);
               scored.sort((a,b) => {
                   if(a.metric !== b.metric) return a.metric - b.metric;
                   return a.metric2 - b.metric2;
               });
               
               if(g % 50 === 0) self.postMessage({ type: 'progress', val: g, total: GENERATIONS });

               let nextGen = [];
               for(let i=0; i<ELITISM; i++) nextGen.push(scored[i].genome);
               
               while(nextGen.length < POP_SIZE) {
                   const p1 = scored[Math.floor(Math.random()*50)].genome;
                   const p2 = scored[Math.floor(Math.random()*50)].genome;
                   let child = new Uint8Array(p1.length);
                   const cut = Math.floor(Math.random() * p1.length);
                   for(let k=0; k<p1.length; k++) child[k] = k < cut ? p1[k] : p2[k];
                   
                   if(Math.random() < 0.2) {
                       const idx = Math.floor(Math.random() * child.length);
                       child[idx] = Math.floor(Math.random() * sCount);
                   }
                   nextGen.push(child);
               }
               population = nextGen;
           }
           
           let best = calcFitness(population[0]);
           
           // Convert back to grid counts
           let counts = []; 
           for(let s=0; s<sCount; s++) counts.push([0,0,0,0]);
           
           for(let i=0; i<best.genome.length; i++) {
               const staffId = best.genome[i];
               const typeId = flatTasks[i].type;
               counts[staffId][typeId]++;
           }
           
           let bestState = [];
           for(let t=0; t<4; t++) {
               let col = [];
               for(let s=0; s<sCount; s++) col.push(counts[s][t]);
               bestState.push(col);
           }
           
           self.postMessage({ type: 'done', bestState, bestMetric: { diff1: best.metric, diff2: best.metric2 } });
        }
    } catch(err) {
        self.postMessage({ type: 'error', msg: err.message });
    }
  };
</script>

<script>
/* --- CONSTANTS & STATE --- */
const icons = {
  moon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`,
  sun: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`,
  lockOpen: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>`,
  lockClosed: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`,
  time: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`,
  cash: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"></rect><circle cx="12" cy="12" r="2"></circle><path d="M6 12h.01M18 12h.01"></path></svg>`,
  trash: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
  layers: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>`
};

// Updated Colors for new palette - REPLACED DARK INDIGO (#3d405b) with Lavender (#a5a8c5) for visibility
const staffColors = ["#e07a5f", "#81b29a", "#a5a8c5", "#f2cc8f", "#7b8cde", "#dfa06e", "#6fab90"];

const toInt = v => { const n = parseInt(v); return isNaN(n)?0:n; }
const inputVal = id => toInt(document.getElementById(id).value);

let currentData = null; 
let combinedData = null; 
let locked = []; 
let staffCount = 0;
let distMode = 'time'; 
let sessionHistory = []; 
let activeWorkers = [];



const defaultTaskConfig = [
  { name: "90m", min: 90, val: 305 },
  { name: "60m Package", min: 60, val: 120 },
  { name: "60m Private", min: 60, val: 205 },
  { name: "15m", min: 15, val: 70 }
];

let taskConfig = JSON.parse(JSON.stringify(defaultTaskConfig));

/* --- DUAL-ENGINE WORKER (Brute Force + Genetic) --- */
const workerScript = `
  self.onmessage = function(e) {
    const { mode, staffCount, taskConfig, targetMode } = e.data;
    
    // --- MODE 1: BRUTE FORCE (Exact, for small inputs) ---
    if (mode === 'brute') {
      const { chunkD0, allD1, allD2, allD3 } = e.data;
      let bestState = null;
      let bestMetric = { diff1: Infinity, diff2: Infinity };
      
      const total = chunkD0.length * allD1.length * allD2.length * allD3.length;
      let processed = 0;
      const reportInterval = Math.max(1000, Math.floor(total / 20));

      for (let d0 of chunkD0) {
        for (let d1 of allD1) {
          for (let d2 of allD2) {
            for (let d3 of allD3) {
              
              let mins = new Array(staffCount).fill(0);
              let revs = new Array(staffCount).fill(0);
              
              for(let s=0; s<staffCount; s++) {
                  mins[s] = d0[s]*taskConfig[0].min + d1[s]*taskConfig[1].min + d2[s]*taskConfig[2].min + d3[s]*taskConfig[3].min;
                  revs[s] = d0[s]*taskConfig[0].val + d1[s]*taskConfig[1].val + d2[s]*taskConfig[2].val + d3[s]*taskConfig[3].val;
              }

              let minT = mins[0], maxT = mins[0];
              let minR = revs[0], maxR = revs[0];
              for(let s=1; s<staffCount; s++){
                  if(mins[s] < minT) minT = mins[s];
                  if(mins[s] > maxT) maxT = mins[s];
                  if(revs[s] < minR) minR = revs[s];
                  if(revs[s] > maxR) maxR = revs[s];
              }

              let diffT = maxT - minT;
              let diffR = maxR - minR;
              
              let dPrimary = targetMode === 'time' ? diffT : diffR;
              let dSecondary = targetMode === 'time' ? diffR : diffT;

              if (dPrimary < bestMetric.diff1 || (dPrimary === bestMetric.diff1 && dSecondary < bestMetric.diff2)) {
                  bestMetric = { diff1: dPrimary, diff2: dSecondary };
                  bestState = [d0, d1, d2, d3];
              }

              processed++;
              if(processed % reportInterval === 0) self.postMessage({ type: 'progress', val: processed, total: total });
            }
          }
        }
      }
      self.postMessage({ type: 'done', bestState, bestMetric });
    } 
    
    // --- MODE 2: GENETIC ALGORITHM (Fast, for large inputs) ---
    else if (mode === 'genetic') {
       const { flatTasks, seed } = e.data;
       
       // PRNG for consistent results across threads if needed, or just Math.random
       // We use a simple population approach
       
       const POP_SIZE = 200;
       const GENERATIONS = 500;
       const ELITISM = 10;
       
       // Genome: Array where index = taskIndex, value = staffID
       let population = [];
       
       // Init Population
       for(let i=0; i<POP_SIZE; i++) {
           let genome = new Uint8Array(flatTasks.length);
           for(let j=0; j<flatTasks.length; j++) genome[j] = Math.floor(Math.random() * staffCount);
           population.push(genome);
       }
       
       const calcFitness = (genome) => {
           let mins = new Array(staffCount).fill(0);
           let revs = new Array(staffCount).fill(0);
           
           for(let i=0; i<genome.length; i++) {
               const s = genome[i];
               const t = flatTasks[i];
               mins[s] += t.min;
               revs[s] += t.val;
           }
           
           let minT = mins[0], maxT = mins[0];
           let minR = revs[0], maxR = revs[0];
           for(let s=1; s<staffCount; s++) {
               if(mins[s] < minT) minT = mins[s];
               if(mins[s] > maxT) maxT = mins[s];
               if(revs[s] < minR) minR = revs[s];
               if(revs[s] > maxR) maxR = revs[s];
           }
           
           const diffT = maxT - minT;
           const diffR = maxR - minR;
           const metric = targetMode === 'time' ? diffT : diffR;
           const metric2 = targetMode === 'time' ? diffR : diffT;
           
           return { genome, metric, metric2, mins, revs };
       };

       for(let g=0; g<GENERATIONS; g++) {
           // 1. Evaluate
           let scored = population.map(calcFitness);
           
           // 2. Sort (Lower metric is better)
           scored.sort((a,b) => {
               if(a.metric !== b.metric) return a.metric - b.metric;
               return a.metric2 - b.metric2;
           });
           
           if(g % 50 === 0) self.postMessage({ type: 'progress', val: g, total: GENERATIONS });

           // 3. Create Next Gen
           let nextGen = [];
           
           // Elitism
           for(let i=0; i<ELITISM; i++) nextGen.push(scored[i].genome);
           
           // Breeding / Mutation
           while(nextGen.length < POP_SIZE) {
               // Tournament Selection
               const p1 = scored[Math.floor(Math.random()*50)].genome; // Pick from top 50
               const p2 = scored[Math.floor(Math.random()*50)].genome;
               
               // Crossover
               let child = new Uint8Array(p1.length);
               const cut = Math.floor(Math.random() * p1.length);
               for(let k=0; k<p1.length; k++) child[k] = k < cut ? p1[k] : p2[k];
               
               // Mutation (Swap Logic)
               if(Math.random() < 0.2) {
                   const idx = Math.floor(Math.random() * child.length);
                   child[idx] = Math.floor(Math.random() * staffCount);
               }
               nextGen.push(child);
           }
           population = nextGen;
       }
       
       // Final Best
       let best = calcFitness(population[0]);
       
       // Convert Genome back to Counts format for the UI
       let counts = []; // Array of staff, each has array of 4 task counts
       for(let s=0; s<staffCount; s++) counts.push([0,0,0,0]);
       
       for(let i=0; i<best.genome.length; i++) {
           const staffId = best.genome[i];
           const typeId = flatTasks[i].type;
           counts[staffId][typeId]++;
       }
       
       // Format matching Brute Force output
       let bestState = [];
       for(let t=0; t<4; t++) {
           let col = [];
           for(let s=0; s<staffCount; s++) col.push(counts[s][t]);
           bestState.push(col);
       }
       
       self.postMessage({ type: 'done', bestState, bestMetric: { diff1: best.metric, diff2: best.metric2 } });
    }
  };
`;

/* --- INIT --- */
function initUI() {
  loadConfig();
  renderRatesPanel();
  renderTheme();
  renderMode();
  loadHistory();
}

/* --- CORE FUNCTIONS --- */
function getCompositions(n, k) {
    if (k === 1) return [[n]];
    let results = [];
    for (let i = 0; i <= n; i++) {
        let rest = getCompositions(n - i, k - 1);
        for (let r of rest) results.push([i, ...r]);
    }
    return results;
}

const delay = ms => new Promise(res => setTimeout(res, ms));

/* --- THE HYBRID SOLVER ENGINE --- */
async function findBestDistribution(sCount, ins, targetMode, silent = false) {
    
    // 1. Calculate Complexity
    // We roughly estimate the search space size
    let complexity = 1;
    for(let i=0; i<4; i++) {
        if (ins[i] > 0) {
            let n = ins[i]; let k = sCount;
            // n+k-1 C k-1
            let top = 1, bot = 1;
            for(let j=0; j<k-1; j++) { top *= (n+k-1-j); bot *= (j+1); }
            complexity *= (top/bot);
        }
    }
    
    // THRESHOLD: If combos > 2 Million, switch to Genetic.
    // iPhone 13 can handle ~5M brute force in 2 seconds.
    // Older phones struggle at 1M. 2M is a safe middle ground.
    const USE_GENETIC = complexity > 2000000;
    
    // UI Update
    if(!silent) {
      document.getElementById('visModal').classList.add('open');
      document.getElementById('visBar').style.width = "0%";
      if(USE_GENETIC) {
          document.getElementById('visStatus').innerText = "Running Genetic Evolution...";
          document.getElementById('visBest').innerText = "Complex Input Detected";
      } else {
          document.getElementById('visStatus').innerText = "Calculating Exact Permutations...";
          document.getElementById('visBest').innerText = "Small Input Detected";
      }
    }
    await delay(10);

    activeWorkers.forEach(w => w.terminate());
    activeWorkers = [];

    const concurrency = navigator.hardwareConcurrency || 4;
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    
    let promises = [];
    
    if (USE_GENETIC) {
        // --- GENETIC PATH ---
        // Flatten tasks for GA
        let flatTasks = [];
        for(let i=0; i<4; i++) {
            for(let k=0; k<ins[i]; k++) flatTasks.push({ type: i, min: taskConfig[i].min, val: taskConfig[i].val });
        }

        // Spawn workers (Parallel Islands Model)
        // Each worker runs its own evolution. We pick the best result of all islands.
        for(let i=0; i<concurrency; i++) {
            const p = new Promise((resolve) => {
                const worker = new Worker(workerUrl);
                activeWorkers.push(worker);
                worker.onmessage = (e) => {
                    if (e.data.type === 'progress' && !silent && i===0) {
                         const pct = ((e.data.val / e.data.total) * 100).toFixed(0);
                         document.getElementById('visBar').style.width = `${pct}%`;
                    }
                    if (e.data.type === 'done') resolve(e.data);
                };
                worker.postMessage({
                    mode: 'genetic',
                    staffCount: sCount,
                    taskConfig: taskConfig,
                    targetMode: targetMode,
                    flatTasks: flatTasks,
                    seed: i 
                });
            });
            promises.push(p);
        }

    } else {
        // --- BRUTE FORCE PATH ---
        const d0 = getCompositions(ins[0], sCount);
        const d1 = getCompositions(ins[1], sCount);
        const d2 = getCompositions(ins[2], sCount);
        const d3 = getCompositions(ins[3], sCount);
        const totalCombinations = d0.length * d1.length * d2.length * d3.length;
        const chunkSize = Math.ceil(d0.length / concurrency);
        
        for (let i = 0; i < concurrency; i++) {
            const start = i * chunkSize; const end = start + chunkSize;
            const chunkD0 = d0.slice(start, end);
            if (chunkD0.length === 0) continue;

            const p = new Promise((resolve) => {
                const worker = new Worker(workerUrl);
                activeWorkers.push(worker);
                let currentProg = 0;
                worker.onmessage = (e) => {
                    if (e.data.type === 'progress') {
                        currentProg = e.data.val;
                        // Approximate visualization for parallel progress
                        if(!silent && i===0) { 
                             // Show progress of first worker as proxy
                             const pct = ((currentProg / (totalCombinations/concurrency)) * 100).toFixed(0);
                             document.getElementById('visBar').style.width = `${pct}%`;
                        }
                    } else if (e.data.type === 'done') resolve(e.data);
                };
                worker.postMessage({
                    mode: 'brute',
                    staffCount: sCount, taskConfig: taskConfig, targetMode: targetMode,
                    chunkD0: chunkD0, allD1: d1, allD2: d2, allD3: d3
                });
            });
            promises.push(p);
        }
    }

    const results = await Promise.all(promises);
    
    // Reduce results to best
    let globalBestState = null;
    let globalBestMetric = { diff1: Infinity, diff2: Infinity };

    results.forEach(res => {
        if (!res.bestState) return;
        let isBetter = false;
        if (res.bestMetric.diff1 < globalBestMetric.diff1) isBetter = true;
        else if (res.bestMetric.diff1 === globalBestMetric.diff1 && res.bestMetric.diff2 < globalBestMetric.diff2) isBetter = true;

        if (isBetter) {
            globalBestMetric = res.bestMetric;
            globalBestState = res.bestState;
        }
    });

    if(!silent) document.getElementById('visModal').classList.remove('open');
    URL.revokeObjectURL(workerUrl);

    if (!globalBestState) return [];

    let result = [];
    for(let s=0; s<sCount; s++) {
        let counts = [globalBestState[0][s], globalBestState[1][s], globalBestState[2][s], globalBestState[3][s]];
        let m=0, r=0;
        counts.forEach((c, i) => { m += c*taskConfig[i].min; r += c*taskConfig[i].val; });
        result.push({ id: s, counts, revenue: r, minutes: m });
    }
    return result;
}

/* --- REST OF APP (Settings, Render, UI) --- */
function toggleSettings() {
  document.getElementById('settingsModal').classList.toggle('open');
}

function toggleTheme() {
  const c = document.documentElement.getAttribute('data-theme');
  const n = c === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', n);
  localStorage.setItem('theme', n);
  renderTheme();
}
function renderTheme() {
  const t = localStorage.getItem('theme') || 'light';
  document.documentElement.setAttribute('data-theme', t);
  document.getElementById('themeBtn').innerHTML = t === 'dark' ? icons.sun : icons.moon;
}

function toggleMode() {
  if (distMode === 'time') distMode = 'revenue';
  else if (distMode === 'revenue') distMode = 'combined';
  else distMode = 'time';
  renderMode();
  if ((currentData || combinedData)) {
      if (distMode === 'combined') initialCalculate();
      else {
           if(locked.some(l => l) && distMode !== 'combined') recalculateUnlocked();
           else initialCalculate();
      }
  }
}
function renderMode() {
  const btn = document.getElementById('modeBtn');
  const lbl = document.getElementById('modeLabel');
  const body = document.body;
  body.classList.remove('mode-time', 'mode-revenue', 'mode-combined');
  body.classList.add(`mode-${distMode}`);
  
  if (distMode === 'time') {
    btn.innerHTML = `${icons.time} HOURS`; 
    btn.classList.add('active-time'); btn.classList.remove('active-rev', 'active-combined');
    lbl.innerHTML = `${icons.time} Prioritizing: HOURS`;
  } else if (distMode === 'revenue') {
    btn.innerHTML = `${icons.cash} REVENUE`; 
    btn.classList.add('active-rev'); btn.classList.remove('active-time', 'active-combined');
    lbl.innerHTML = `${icons.cash} Prioritizing: REVENUE`;
  } else {
    btn.innerHTML = `${icons.layers} COMBINED`; 
    btn.classList.add('active-combined'); btn.classList.remove('active-time', 'active-rev');
    lbl.innerHTML = `${icons.layers} Prioritizing: COMBINED`;
  }
}

function loadConfig() {
  const saved = localStorage.getItem('task_config');
  if(saved) {
    try {
      const parsed = JSON.parse(saved);
      taskConfig = defaultTaskConfig.map((def, i) => {
        const p = parsed[i] || {};
        return {
          name: p.name || def.name,
          min: p.min !== undefined ? p.min : def.min,
          val: p.val !== undefined ? p.val : def.val
        };
      });
    } catch(e) { taskConfig = JSON.parse(JSON.stringify(defaultTaskConfig)); }
  }
  updateInputLabels();
}

function saveConfig() {
  for(let i=0; i<4; i++) {
    taskConfig[i].name = document.getElementById(`cfg_name_${i}`).value || `Task ${i+1}`;
    taskConfig[i].min = toInt(document.getElementById(`cfg_min_${i}`).value);
    taskConfig[i].val = toInt(document.getElementById(`cfg_val_${i}`).value);
  }
  localStorage.setItem('task_config', JSON.stringify(taskConfig));
  updateInputLabels(); updateStats();
  if (currentData || combinedData) renderGrid();
}

function renderRatesPanel() {
  const container = document.getElementById('ratesPanel'); container.innerHTML = '';
  taskConfig.forEach((cfg, i) => {
    container.innerHTML += `
      <div class="rate-row">
        <input class="rate-name" type="text" id="cfg_name_${i}" value="${cfg.name}" placeholder="Name" oninput="saveConfig()">
        <div class="rate-input-group"><input class="rate-input" type="number" id="cfg_min_${i}" value="${cfg.min}" oninput="saveConfig()"><span>m</span></div>
        <div class="rate-input-group"><input class="rate-input" type="number" id="cfg_val_${i}" value="${cfg.val}" oninput="saveConfig()"><span>RM</span></div>
      </div>`;
  });
}

function updateInputLabels() {
  taskConfig.forEach((cfg, i) => { document.getElementById(`lbl_${i}`).innerText = `${cfg.name} (${cfg.val})`; });
}

function updateStats(){
  let count = 0; let hrs = 0;
  let complexity = 1;
  const sCount = Math.max(1, inputVal("totalStaff"));
  
  for(let i=0; i<4; i++) { 
    const qty = inputVal(`in_${i}`); 
    count += qty; 
    hrs += (qty * taskConfig[i].min); 
    
    if (qty > 0) {
       const n = qty; const k = sCount;
       let top = 1; let bot = 1;
       let limit = Math.min(k-1, n); // optimization
       for(let j=0; j<k-1; j++) { top *= (n+k-1-j); bot *= (j+1); }
       complexity *= (top/bot);
    }
  }
  hrs = hrs / 60;
  document.getElementById("valCount").innerText = count;
  document.getElementById("valHours").innerText = (Number.isInteger(hrs)?hrs:hrs.toFixed(1))+"h";

  let compStr = "-";
  if (count > 0) {
      if (complexity >= 1000000) compStr = (complexity / 1000000).toFixed(1) + "M";
      else if (complexity >= 1000) compStr = (complexity / 1000).toFixed(1) + "k";
      else compStr = Math.round(complexity);
      
      // Update logic label
      const useGA = complexity > 2000000;
      compStr += useGA ? ` (Genetic)` : ` (Exact)`;
  }
  document.getElementById("valComplexity").innerText = compStr;
}

async function saveDualRecord() {
    const btn = document.querySelector('.btn-save');
    const originalText = btn.innerText;
    
    if(!currentData && !combinedData) {
        alert("Please distribute first.");
        return;
    }

    btn.innerText = "Saving...";
    btn.disabled = true;
    await delay(50);

    try {
        const sCount = staffCount;
        let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));

        const resTime = await findBestDistribution(sCount, ins, 'time', true);
        const resRev = await findBestDistribution(sCount, ins, 'revenue', true);
        
        if (!resTime || !resRev || resTime.length === 0 || resRev.length === 0) {
            throw new Error("Calculation failed");
        }

        const mapRes = (r) => r.map(s => ({id:s.id+1, counts:s.counts, rev:s.revenue, mins:s.minutes}));

        const record = {
            id: Date.now(),
            date: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
            staffCount: sCount,
            config: JSON.parse(JSON.stringify(taskConfig)),
            resTime: mapRes(resTime),
            resRev: mapRes(resRev)
        };

        sessionHistory.unshift(record);
        loadHistory();
        
    } catch (e) {
        console.error(e);
        alert("Error saving: " + e.message);
    } finally {
        btn.innerText = originalText;
        btn.disabled = false;
    }
}

async function initialCalculate(){
  staffCount = Math.max(1, inputVal("totalStaff"));
  let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));
  const totalTasks = ins.reduce((a,b)=>a+b,0);
  
  if(staffCount<=0 || totalTasks===0) { alert("Please check inputs"); return; }
  
  if (distMode === 'combined') {
      const rTime = await findBestDistribution(staffCount, ins, 'time');
      const rRev = await findBestDistribution(staffCount, ins, 'revenue');
      
      if (!rTime || !rRev) { alert("Calculation failed."); return; }
      
      combinedData = {
          timeRes: rTime.map(s => ({...s, counts:[...s.counts]})),
          revRes: rRev.map(s => ({...s, counts:[...s.counts]}))
      };
      currentData = null; 
  } else {
      const bestResult = await findBestDistribution(staffCount, ins, distMode);
      if (!bestResult || bestResult.length === 0) { alert("Calculation failed."); return; }

      currentData = { counts: [] };
      bestResult.forEach(s => { currentData.counts.push([...s.counts]); });
      combinedData = null;
  }
  
  locked = new Array(staffCount).fill(false);
  renderGrid(); 
  document.getElementById("recalcBtn").style.display = "none";
}

function recalculateUnlocked(){
  if (distMode === 'combined' || !currentData) return;
  
  let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));
  let held = [0,0,0,0]; let states = [];
  
  for (let s=0; s<staffCount; s++){
    const l = locked[s]; let sTasks = []; let sCounts = currentData.counts[s];
    if(l) { 
        for(let i=0; i<4; i++) {
            held[i] += sCounts[i];
            for(let k=0; k<sCounts[i]; k++) sTasks.push({ dur: taskConfig[i].min, val: taskConfig[i].val, typeIdx: i });
        }
    }
    let m = 0; let r = 0; sTasks.forEach(t => { m+=t.dur; r+=t.val; });
    states.push({ id:s, locked:l, minutes:l?m:0, revenue:l?r:0, tasks: sTasks, counts: l ? [...sCounts] : [0,0,0,0] });
  }
  
  for(let i=0; i<4; i++) if(held[i] > ins[i]) { alert("Locked values exceed inputs"); return; }
  
  let pool = [];
  for(let i=0; i<4; i++) {
      const needed = ins[i] - held[i];
      for(let k=0; k<needed; k++) pool.push({ dur: taskConfig[i].min, val: taskConfig[i].val, typeIdx: i });
  }
  
  if(pool.length) {
      pool.sort((a, b) => {
          if (distMode === 'time') return b.dur - a.dur;
          else {
              if (b.val !== a.val) return b.val - a.val;
              return b.dur - a.dur;
          }
      });
      pool.forEach(task => {
        let bestIdx = -1; let minPrimary = Infinity; let minSecondary = Infinity;
        for (let i=0; i<states.length; i++) {
            if (states[i].locked) continue;
            const sRev = states[i].revenue; const sTime = states[i].minutes;
            const cPri = distMode === 'time' ? sTime : sRev;
            const cSec = distMode === 'time' ? 0 : sTime;
            if (cPri < minPrimary) { minPrimary = cPri; minSecondary = cSec; bestIdx = i; } 
            else if (cPri === minPrimary) {
                if (distMode === 'revenue' && cSec < minSecondary) { minSecondary = cSec; bestIdx = i; } 
                else if (distMode === 'time') { bestIdx = i; }
            }
        }
        if (bestIdx !== -1) {
            states[bestIdx].minutes += task.dur; states[bestIdx].revenue += task.val;
            states[bestIdx].tasks.push(task); states[bestIdx].counts[task.typeIdx]++;
        }
      });
  }
  
  currentData = { counts: [] }; 
  states.forEach(s => { currentData.counts.push([...s.counts]); });
  renderGrid();
}

function generateVarianceBadges(dataArr) {
    if(!dataArr) return "";
    const mins = dataArr.map(s => s.minutes || s.mins);
    const minT = Math.min(...mins); const maxT = Math.max(...mins);
    let tVar = minT > 0 ? (((maxT-minT)/minT)*100).toFixed(1) : "0.0";
    let tClass = parseFloat(tVar) < 10 ? 'ok' : (parseFloat(tVar) < 20 ? 'warn' : 'bad');
    let tBadge = `<span class="var-badge ${tClass}">Time: ${tVar}%</span>`;

    const revs = dataArr.map(s => s.revenue || s.rev);
    const minRev = Math.min(...revs); const maxRev = Math.max(...revs);
    let rVar = minRev > 0 ? (((maxRev - minRev) / minRev) * 100).toFixed(1) : "0.0";
    let rClass = parseFloat(rVar) < 10 ? 'ok' : (parseFloat(rVar) < 20 ? 'warn' : 'bad');
    let rBadge = `<span class="var-badge ${rClass}">Rev: ${rVar}%</span>`;

    return `<div class="var-area" style="margin-left:auto; display:flex; gap:6px;">${tBadge}${rBadge}</div>`;
}

function loadHistory() {
  const list = document.getElementById('historyList');
  if (sessionHistory.length === 0) { 
    document.getElementById('historySection').classList.remove('has-data'); 
    return; 
  }
  document.getElementById('historySection').classList.add('has-data');
  list.innerHTML = '';

  const renderStaffGrid = (staffData, cfg) => {
      let html = '';
      staffData.forEach((staff, idx) => {
          const color = staffColors[idx % staffColors.length];
          const hrs = (staff.mins / 60).toFixed(1);
          let breakdown = [];
          staff.counts.forEach((c, i) => { if(c > 0) breakdown.push(`${cfg[i].name}:<b>${c}</b>`); });
          html += `<div class="rec-staff-item"><div class="rsi-name" style="color:${color}">Staff ${staff.id}</div><div class="rsi-stats"><div class="rsi-money">RM ${staff.rev}</div><div class="rsi-time">${hrs}h</div></div><div class="rsi-tasks">${breakdown.join(' &bull; ')}</div></div>`;
      });
      return html;
  };

  sessionHistory.forEach(rec => {
    list.innerHTML += `
      <div class="rec-card">
        <div class="rec-meta">
          <span class="rec-date">${rec.date}</span>
          <button class="btn-del-rec" onclick="deleteRecord(${rec.id})">${icons.trash}</button>
        </div>
        <div>
          <div class="rec-row-header">
            <div class="rec-row-label lbl-time">${icons.time} Opt: HOURS</div>
            ${generateVarianceBadges(rec.resTime)}
          </div>
          <div class="rec-staff-grid">${renderStaffGrid(rec.resTime, rec.config)}</div>
        </div>
        <div style="margin-top:10px; border-top:1px dashed var(--border); padding-top:10px;">
          <div class="rec-row-header">
             <div class="rec-row-label lbl-rev">${icons.cash} Opt: REVENUE</div>
             ${generateVarianceBadges(rec.resRev)}
          </div>
          <div class="rec-staff-grid">${renderStaffGrid(rec.resRev, rec.config)}</div>
        </div>
      </div>`;
  });
}

function deleteRecord(id) {
  sessionHistory = sessionHistory.filter(r => r.id !== id);
  loadHistory();
}

function renderGrid(){
  const container = document.getElementById("resultsContainer"); 
  container.innerHTML = "";
  
  const calcStats = (counts) => {
      let allM = [], allR = [];
      counts.forEach((cnt, idx) => {
          let m=0, r=0;
          cnt.forEach((c, k) => { m += c * taskConfig[k].min; r += c * taskConfig[k].val; });
          allM.push(m); allR.push(r);
      });
      return { mins: allM, revs: allR };
  };

  const generateCards = (dataCounts, modeName) => {
      let html = "";
      dataCounts.forEach((myCounts, i) => {
        const c = staffColors[i % staffColors.length];
        let totalMins = 0; let totalRev = 0;
        myCounts.forEach((cnt, idx) => { totalMins += cnt * taskConfig[idx].min; totalRev += cnt * taskConfig[idx].val; });
        const hrs = totalMins/60; const hrsTxt = Number.isInteger(hrs) ? hrs : hrs.toFixed(1);
        
        let heroHTML, subHTML;
        if (modeName === 'time') { heroHTML = `${hrsTxt}<span>h</span>`; subHTML = ``; }
        else if (modeName === 'revenue') { heroHTML = `<span class="prefix">RM</span>${totalRev}`; subHTML = `${hrsTxt}h`; }
        else { heroHTML = `${hrsTxt}<span>h</span>`; subHTML = `<span class="prefix">RM</span>${totalRev}`; }

        const isLocked = locked[i]; 
        const lockClass = isLocked ? "locked" : ""; 
        const lockIcon = isLocked ? icons.lockClosed : icons.lockOpen;
        const disableLock = distMode === 'combined' ? 'disabled' : ''; 

        let tasksHTML = "";
        for(let k=0; k<4; k++) {
            const cnt = myCounts[k]; const cssClass = cnt > 0 ? "" : "is-zero"; const label = taskConfig[k].name;
            tasksHTML += `<div class="task-row ${cssClass}"><span class="task-label">${label}</span><input class="task-input" type="number" data-staff="${i}" data-idx="${k}" data-mode="${modeName}" value="${cnt}" oninput="manualEdit(this)"></div>`;
        }
        
        html += `<div class="staff-card"><div class="card-border-top" style="background:${c}"></div><div class="card-header"><div class="staff-name" style="color:${c}">Staff ${i+1}</div><button class="lock-btn ${lockClass} ${disableLock}" onclick="toggleLock(${i})" aria-label="Lock">${lockIcon}</button></div><div class="card-hero"><div class="hero-main">${heroHTML}</div><div class="hero-sub"><div class="hero-sec">${subHTML}</div></div></div><div class="card-tasks">${tasksHTML}</div></div>`;
      });
      return html;
  };

  if (distMode === 'combined' && combinedData) {
      container.innerHTML = `
        <div class="split-grid-wrapper">
           <div class="grid-title">${icons.time} Optimized for HOURS ${generateVarianceBadges(combinedData.timeRes)}</div>
           <div class="results-grid">${generateCards(combinedData.timeRes.map(s=>s.counts), 'combined_t')}</div>
        </div>
        <div class="split-grid-wrapper" style="margin-top:12px; border-top:2px dashed var(--border); padding-top:12px;">
           <div class="grid-title">${icons.cash} Optimized for REVENUE ${generateVarianceBadges(combinedData.revRes)}</div>
           <div class="results-grid">${generateCards(combinedData.revRes.map(s=>s.counts), 'combined_r')}</div>
        </div>
      `;
  } else if (currentData) {
      const stats = calcStats(currentData.counts);
      
      const minT = Math.min(...stats.mins); const maxT = Math.max(...stats.mins);
      let tVar = minT > 0 ? (((maxT-minT)/minT)*100).toFixed(1) : "0.0";
      let tClass = parseFloat(tVar) < 10 ? 'ok' : (parseFloat(tVar) < 20 ? 'warn' : 'bad');
      
      const minR = Math.min(...stats.revs); const maxR = Math.max(...stats.revs);
      let rVar = minR > 0 ? (((maxR-minR)/minR)*100).toFixed(1) : "0.0";
      let rClass = parseFloat(rVar) < 10 ? 'ok' : (parseFloat(rVar) < 20 ? 'warn' : 'bad');

      const badgesHTML = `
        <div style="display:flex; justify-content:flex-end; gap:6px; margin-bottom:8px;">
          <span class="var-badge ${tClass}">Time: ${tVar}%</span>
          <span class="var-badge ${rClass}">Rev: ${rVar}%</span>
        </div>`;
      
      container.innerHTML = badgesHTML + `<div class="results-grid">${generateCards(currentData.counts, distMode)}</div>`;
  } else {
      container.innerHTML = `<div class="empty-state">Enter inputs to distribute workload...</div>`;
  }
}

function manualEdit(el){
  const staff = parseInt(el.getAttribute('data-staff')); 
  const idx = parseInt(el.getAttribute('data-idx'));
  const mode = el.getAttribute('data-mode');
  let val = parseInt(el.value);
  if(isNaN(val)) val = 0;
  
  if (distMode === 'combined') {
     if(mode === 'combined_t') combinedData.timeRes[staff].counts[idx] = val;
     if(mode === 'combined_r') combinedData.revRes[staff].counts[idx] = val;
     const recalc = (arr) => {
         let m=0, r=0;
         arr[staff].counts.forEach((c, k) => { m += c * taskConfig[k].min; r += c * taskConfig[k].val; });
         arr[staff].minutes = m; arr[staff].revenue = r;
     }
     if(mode === 'combined_t') recalc(combinedData.timeRes);
     else recalc(combinedData.revRes);
     
  } else {
      currentData.counts[staff][idx] = val;
  }
  renderGrid();
}

function toggleLock(i){ 
    if(distMode === 'combined') return; 
    locked[i] = !locked[i]; 
    document.getElementById("recalcBtn").style.display = locked.some(x=>x) ? "flex" : "none"; 
    renderGrid(); 
}

function resetAll(){
  document.getElementById("totalStaff").value = "";
  for(let i=0; i<4; i++) document.getElementById(`in_${i}`).value = "";
  updateStats();
  document.getElementById("resultsContainer").innerHTML = `<div class="empty-state">Enter inputs to distribute workload...</div>`;
  currentData = null; combinedData = null; locked=[]; staffCount=0;
  document.getElementById("recalcBtn").style.display = "none";
}

initUI();
</script>
</body>
</html>
