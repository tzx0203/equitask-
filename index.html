<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" />
<title>Workload Distributor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    /* New Palette definition */
    --c-eggshell: #f4f1de;
    --c-burnt-peach: #e07a5f;
    --c-indigo: #3d405b;
    --c-teal: #81b29a;
    --c-apricot: #f2cc8f;
    --c-white: #ffffff;
    --c-periwinkle: #7b8cde;
    
    /* Functional mapping */
    --bg-body: var(--c-eggshell);
    --text-main: var(--c-indigo);
    --text-muted: rgba(61, 64, 91, 0.65);
    --border: rgba(61, 64, 91, 0.08);
    --card-bg: var(--c-white);
    --input-bg: rgba(61, 64, 91, 0.04);
    --input-focus-bg: #fff;
    
    --primary: var(--c-burnt-peach);
    --success: var(--c-teal);
    --warning: var(--c-apricot);
    --danger: #d95d5d;
    
    --mode-color: var(--c-indigo);
    --radius-sm: 12px;
    --radius-md: 20px;
    --radius-lg: 30px;
    
    /* Minimalist Shadows */
    --shadow-soft: 0 4px 20px -2px rgba(61, 64, 91, 0.06);
    --shadow-hover: 0 10px 25px -5px rgba(61, 64, 91, 0.1);

    /* Badge Colors (Light Mode) */
    --badge-ok-bg: rgba(129, 178, 154, 0.2);
    --badge-ok-text: #2d6a55;
    --badge-warn-bg: rgba(242, 204, 143, 0.3);
    --badge-warn-text: #8f6014;
    --badge-bad-bg: rgba(224, 122, 95, 0.2);
    --badge-bad-text: #a83232;
  }

  [data-theme="dark"] {
    --bg-body: #282a3a;
    --text-main: #f4f1de;
    --text-muted: rgba(244, 241, 222, 0.6);
    --border: rgba(244, 241, 222, 0.1);
    --card-bg: #323548;
    --input-bg: rgba(0, 0, 0, 0.2);
    --input-focus-bg: #3b3e54;
    --primary: #e07a5f;
    --success: #81b29a;
    --warning: #f2cc8f;
    --shadow-soft: 0 10px 30px -10px rgba(0, 0, 0, 0.3);
    --shadow-hover: 0 15px 35px -5px rgba(0, 0, 0, 0.4);
    
    /* Badge Colors (Dark Mode) - Lighter text for contrast */
    --badge-ok-text: #81b29a;
    --badge-warn-text: #f2cc8f;
    --badge-bad-text: #e07a5f;
  }

  /* Distinct Mode Colors */
  body.mode-time { --mode-color: var(--c-burnt-peach); }
  body.mode-revenue { --mode-color: var(--c-teal); }
  body.mode-combined { --mode-color: var(--c-periwinkle); }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-body);
    color: var(--text-main);
    margin: 0; padding: 16px;
    display: flex; justify-content: center;
    min-height: 100vh;
    transition: background-color 0.3s, color 0.3s;
  }

  .app-wrapper { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 20px; }

  /* --- HEADER --- */
  header { display: flex; justify-content: space-between; align-items: center; gap: 8px; padding-bottom: 4px; }
  h1 { font-size: 20px; font-weight: 800; margin: 0; letter-spacing: -0.02em; flex: 1; color: var(--text-main); }
  .header-controls { display: flex; gap: 8px; }

  .icon-btn {
    background: transparent; border: none;
    border-radius: var(--radius-sm); cursor: pointer; color: var(--text-muted);
    padding: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.2s; height: 38px; width: 38px;
  }
  .icon-btn:hover { background: var(--input-bg); color: var(--text-main); }
  .icon-btn svg { width: 20px; height: 20px; stroke-width: 2; }
  
  #modeBtn { 
    color: var(--mode-color); font-weight: 700; 
    width: auto; padding: 0 14px; gap: 6px; font-size: 12px; 
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    box-shadow: 0 2px 10px rgba(0,0,0,0.03);
  }
  #modeBtn svg { width: 14px; height: 14px; }
  
  /* --- CONFIG --- */
  .config-container {
    background: var(--card-bg); 
    border-radius: var(--radius-md);
    padding: 20px; 
    display: flex; flex-direction: column; gap: 20px;
    box-shadow: var(--shadow-soft);
  }

  .mode-indicator {
    font-size: 10px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;
    color: var(--mode-color); display: flex; align-items: center; gap: 6px;
    margin-bottom: 4px; opacity: 0.9;
  }
  .mode-indicator svg { width: 12px; height: 12px; }

  /* Compact Input Grid */
  .input-strip { 
    display: grid; 
    grid-template-columns: repeat(3, 1fr); 
    gap: 10px; 
    align-items: end;
  }
  @media (min-width: 450px) {
    .input-strip { grid-template-columns: repeat(5, 1fr); }
  }

  .input-group { display: flex; flex-direction: column; gap: 6px; }
  
  .input-group label { 
    font-size: 10px; font-weight: 700; color: var(--text-muted); 
    letter-spacing: 0.03em; text-align: center;
    overflow: hidden; white-space: nowrap; text-overflow: ellipsis; 
  }
  .input-group input {
    width: 100%; padding: 10px 4px; text-align: center; border-radius: var(--radius-sm);
    border: 1px solid transparent; background: var(--input-bg); color: var(--text-main);
    font-size: 15px; font-weight: 700; transition: all 0.2s;
    font-family: inherit; -moz-appearance: textfield;
  }
  .input-group input::-webkit-outer-spin-button,
  .input-group input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  
  .input-group input:focus { 
    outline: none; background: var(--input-focus-bg); 
    border-color: var(--mode-color); 
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); 
  }
  .input-group input::placeholder { color: var(--text-muted); opacity: 0.3; }

  /* Stats & Actions */
  .action-strip {
    display: flex; flex-direction: column; gap: 16px;
    padding-top: 4px;
  }
  
  .stats-area { 
    display: flex; gap: 8px 16px; flex-wrap: wrap; 
    justify-content: center; padding: 4px 0;
  }
  .stat-pill {
    font-size: 11px; color: var(--text-muted); font-weight: 500;
    display: flex; align-items: center; gap: 4px;
  }
  .stat-pill strong { color: var(--text-main); font-weight: 700; }
  
  .btn-area { display: grid; grid-template-columns: auto auto 1fr; gap: 8px; width: 100%; }
  
  button.action-btn {
    cursor: pointer; font-size: 12px; font-weight: 700; padding: 10px 12px;
    border-radius: var(--radius-lg); border: none; transition: all 0.2s;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Inter', sans-serif;
  }
  button.action-btn:active { transform: scale(0.97); }
  
  .btn-reset { background: transparent; color: var(--text-muted); padding: 10px; }
  .btn-reset:hover { background: var(--input-bg); color: var(--danger); }
  
  .btn-save { background: var(--input-bg); color: var(--text-main); }
  .btn-save:hover { background: #e5e6eb; }
  
  .btn-go { background: var(--mode-color); color: white; box-shadow: 0 4px 15px -4px rgba(0,0,0,0.2); }
  .btn-go:hover { opacity: 0.95; box-shadow: 0 6px 20px -4px rgba(0,0,0,0.25); }
  
  .btn-recalc { background: var(--success); color: white; grid-column: 3; }

  /* --- SETTINGS MODAL --- */
  .modal-backdrop {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(61, 64, 91, 0.2); z-index: 100; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
  }
  .modal-backdrop.open { display: flex; }
  .settings-card {
    background: var(--card-bg); width: 90%; max-width: 380px;
    border-radius: var(--radius-md); padding: 24px; border: none;
    box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.15);
    display: flex; flex-direction: column; gap: 20px;
  }
  .settings-header { display: flex; justify-content: space-between; align-items: center; }
  .settings-title { font-size: 18px; font-weight: 800; color: var(--text-main); }
  .close-modal { background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-muted); padding: 0; line-height: 1; }
  
  .setting-section { display: flex; flex-direction: column; gap: 8px; }
  .setting-label { font-size: 10px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.8px; }
  
  .select-box {
    width: 100%; padding: 12px; border-radius: var(--radius-sm); border: 1px solid transparent;
    background: var(--input-bg); color: var(--text-main); font-size: 13px; font-weight: 600;
    outline: none; transition: 0.2s;
  }
  .rate-rows-container { display: flex; flex-direction: column; gap: 8px; }
  .rate-row { display: flex; gap: 8px; align-items: center; }
  .rate-name { 
    flex: 1.5; padding: 10px; border-radius: var(--radius-sm); border: 1px solid transparent; 
    font-size: 13px; font-weight: 600; color: var(--text-main); background: var(--input-bg); min-width: 0; 
  }
  .rate-input-group { flex: 1; display: flex; gap: 4px; align-items: center; min-width: 0; position: relative; }
  .rate-input-group span { position: absolute; right: 8px; font-size: 10px; color: var(--text-muted); font-weight: 600; pointer-events: none; }
  .rate-input { 
    width: 100%; padding: 10px 24px 10px 8px; border-radius: var(--radius-sm); 
    border: 1px solid transparent; font-size: 13px; font-weight: 600; 
    color: var(--text-main); background: var(--input-bg); text-align: center; min-width: 0; 
  }
  .rate-name:focus, .rate-input:focus, .select-box:focus { background: var(--input-focus-bg); border-color: var(--mode-color); }

  .btn-done { background: var(--mode-color); color: white; width: 100%; padding: 14px; border-radius: var(--radius-sm); border: none; font-weight: 700; cursor: pointer; font-size: 13px; margin-top: 8px; }

  /* --- RESULTS --- */
  .results-container { display: flex; flex-direction: column; gap: 24px; padding-bottom: 40px; }
  .split-grid-wrapper { display: flex; flex-direction: column; gap: 12px; }
  .grid-title { 
    font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; 
    letter-spacing: 0.8px; display: flex; align-items: center; gap: 8px;
    padding-bottom: 6px; border-bottom: 1px solid var(--border);
  }
  .grid-title svg { width: 14px; height: 14px; color: var(--mode-color); }
  
  .results-grid { 
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(145px, 1fr)); 
    gap: 10px; width: 100%; 
  }

  .staff-card {
    background: var(--card-bg); border-radius: var(--radius-md); border: none;
    box-shadow: var(--shadow-soft); overflow: hidden;
    display: flex; flex-direction: column; transition: transform 0.2s;
  }
  .staff-card:hover { transform: translateY(-2px); }
  
  .card-border-top { height: 4px; width: 100%; }
  
  .card-header { padding: 8px 10px 0 10px; display: flex; justify-content: space-between; align-items: center; }
  .staff-name { font-size: 10px; font-weight: 800; opacity: 0.9; text-transform: uppercase; letter-spacing: 0.5px; }
  
  .lock-btn {
    background: transparent; border: none; cursor: pointer; 
    color: var(--text-muted); padding: 4px; border-radius: 50%;
    opacity: 0.3; transition: 0.2s;
  }
  .lock-btn:hover { opacity: 1; color: var(--text-main); background: var(--input-bg); }
  .lock-btn svg { width: 14px; height: 14px; }
  .lock-btn.locked { color: var(--mode-color); opacity: 1; background: rgba(0,0,0,0.03); }

  .card-hero { padding: 4px 10px 10px 10px; text-align: left; }
  .hero-main { font-size: 28px; font-weight: 800; color: var(--text-main); letter-spacing: -1px; line-height: 1; display: flex; align-items: baseline; }
  .hero-main span { font-size: 14px; font-weight: 600; color: var(--text-muted); margin-left: 2px; }
  .hero-main span.prefix { margin-right: 2px; margin-left: 0; font-size: 16px; }
  
  .hero-sub { display: flex; align-items: center; gap: 6px; margin-top: 6px; }
  .hero-sec { 
    font-size: 10px; font-weight: 700; color: var(--text-muted); 
    background: var(--input-bg); padding: 3px 8px; border-radius: 12px; 
  }

  .card-tasks { 
    padding: 8px; background: var(--input-bg); flex: 1; 
    display: flex; flex-direction: column; gap: 4px; 
  }
  .task-row { 
    display: flex; align-items: center; justify-content: space-between; 
    background: var(--card-bg); padding: 6px 8px; border-radius: 8px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.01); 
  }
  .task-row.is-zero { display: none; }
  .task-label { font-size: 10px; font-weight: 600; color: var(--text-muted); max-width: 80px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .task-input { width: 40px; border: none; background: transparent; text-align: right; font-size: 12px; font-weight: 700; color: var(--text-main); padding: 0; outline: none; }
  
  .empty-state { text-align: center; width: 100%; color: var(--text-muted); padding: 40px 20px; font-weight: 500; font-size: 13px; opacity: 0.7; }

  /* History */
  .history-section { display: none; flex-direction: column; gap: 16px; }
  .history-section.has-data { display: flex; }
  .history-title { font-size: 12px; font-weight: 800; color: var(--text-main); text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }

  .rec-card { 
    background: var(--card-bg); border-radius: var(--radius-md); 
    padding: 16px; display: flex; flex-direction: column; gap: 12px; 
    box-shadow: var(--shadow-soft);
  }
  .rec-meta { display: flex; justify-content: space-between; align-items: center; }
  .rec-date { font-size: 11px; font-weight: 700; color: var(--text-muted); background: var(--input-bg); padding: 4px 10px; border-radius: 20px; }
  
  .btn-del-rec { 
    border: none; background: transparent; color: var(--danger); 
    cursor: pointer; padding: 4px; opacity: 0.5; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
  }
  .btn-del-rec:hover { opacity: 1; background: var(--input-bg); }
  .btn-del-rec svg { width: 14px; height: 14px; }

  .rec-row-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .rec-row-label { font-size: 10px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 6px; color: var(--text-muted); }
  
  .var-badge { font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 6px; }
  
  .var-badge.ok { background: var(--badge-ok-bg); color: var(--badge-ok-text); }
  .var-badge.warn { background: var(--badge-warn-bg); color: var(--badge-warn-text); }
  .var-badge.bad { background: var(--badge-bad-bg); color: var(--badge-bad-text); }

  .rec-staff-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
  .rec-staff-item { background: var(--input-bg); border-radius: var(--radius-sm); padding: 8px; display: flex; flex-direction: column; gap: 4px; }
  .rsi-name { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; }
  .rsi-stats { display: flex; justify-content: space-between; align-items: center; }
  .rsi-money { font-size: 10px; font-weight: 700; color: var(--success); }
  .rsi-time { font-size: 10px; font-weight: 700; color: var(--text-main); }
  .rsi-tasks { font-size: 9px; color: var(--text-muted); margin-top: 4px; border-top: 1px dashed rgba(0,0,0,0.05); padding-top: 4px; }

  /* Visualization Modal */
  .vis-modal {
    position: fixed; top:0; left:0; width:100%; height:100%;
    background: rgba(244, 241, 222, 0.8); z-index: 200;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    backdrop-filter: blur(5px);
  }
  .vis-modal.open { display: flex; }
  .vis-card {
    background: var(--card-bg); width: 85%; max-width: 300px; padding: 32px 24px;
    border-radius: var(--radius-lg); text-align: center; color: var(--text-main);
    display: flex; flex-direction: column; align-items: center;
    box-shadow: 0 20px 50px rgba(61, 64, 91, 0.15);
  }
  .vis-spinner { 
    width: 36px; height: 36px; 
    border: 3px solid var(--input-bg); border-top-color: var(--mode-color); 
    border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px; 
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .vis-title { font-weight: 800; font-size: 16px; margin-bottom: 12px; }
  .vis-bar-bg { width: 100%; height: 6px; background: var(--input-bg); border-radius: 4px; overflow: hidden; margin-bottom: 12px; width: 100%; }
  .vis-bar-fill { height: 100%; background: var(--mode-color); width: 0%; transition: width 0.2s ease-out; }
  .vis-stat { font-size: 11px; color: var(--text-muted); margin-bottom: 4px; font-weight: 600; }
  .vis-cancel-btn {
      margin-top: 20px; background: transparent; color: var(--danger); border: none;
      padding: 8px 20px; border-radius: 20px; font-weight: 700; font-size: 12px; cursor: pointer;
      transition: all 0.2s;
  }
  .vis-cancel-btn:hover { background: var(--input-bg); }

</style>
</head>
<body class="mode-time">

<div class="app-wrapper">
  
  <header>
    <h1>Workload Distributor</h1>
    <div class="header-controls">
      <button class="icon-btn" onclick="toggleSettings()" title="Settings">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
      </button>
      <button class="icon-btn" onclick="toggleMode()" id="modeBtn" title="Switch Logic">
        <!-- Icon injected JS -->
      </button>
      <button class="icon-btn" onclick="toggleTheme()" id="themeBtn" title="Toggle Theme">
        <!-- Icon Injected by JS -->
      </button>
    </div>
  </header>

  <!-- Config -->
  <div class="config-container">
    <div class="mode-indicator" id="modeLabel">PRIORITY: HOURS</div>

    <div class="input-strip">
      <div class="input-group">
        <label>Staff</label>
        <input id="totalStaff" type="number" min="1" placeholder="4" inputmode="numeric">
      </div>
      <div class="input-group"><label id="lbl_0">Task 1</label><input id="in_0" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_1">Task 2</label><input id="in_1" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_2">Task 3</label><input id="in_2" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
      <div class="input-group"><label id="lbl_3">Task 4</label><input id="in_3" type="number" min="0" placeholder="0" inputmode="numeric" oninput="updateStats()"></div>
    </div>

    <div class="action-strip">
      <div class="stats-area">
        <div class="stat-pill">Orders: <strong id="valCount">0</strong></div>
        <div class="stat-pill">Time: <strong id="valHours">0h</strong></div>
        <div class="stat-pill">Combos: <strong id="valComplexity">-</strong></div>
      </div>
      <div class="btn-area">
        <button class="action-btn btn-reset" onclick="resetAll()">Reset</button>
        <button class="action-btn btn-save" onclick="saveDualRecord()">Save</button>
        <button id="calcBtn" class="action-btn btn-go" onclick="initialCalculate()">Distribute</button>
        <button id="recalcBtn" class="action-btn btn-recalc" onclick="recalculateUnlocked()" style="display:none;">Recalc</button>
      </div>
    </div>
  </div>

  <!-- Results -->
  <div id="resultsContainer" class="results-container">
    <div class="empty-state">Enter inputs to distribute workload...</div>
  </div>

  <!-- History -->
  <div id="historySection" class="history-section">
    <div class="history-title">Saved Records</div>
    <div id="historyList" style="display:flex; flex-direction:column; gap:12px;"></div>
  </div>

</div>

<!-- Visualization Overlay -->
<div id="visModal" class="vis-modal">
  <div class="vis-card">
    <div class="vis-spinner"></div>
    <div class="vis-title">Optimizing...</div>
    <div class="vis-bar-bg"><div id="visBar" class="vis-bar-fill"></div></div>
    <div id="visStatus" class="vis-stat">Initializing...</div>
    <div id="visBest" class="vis-stat">Best Diff: -</div>
    <button class="vis-cancel-btn" onclick="cancelCalculation()">Cancel</button>
  </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal-backdrop">
  <div class="settings-card">
    <div class="settings-header">
      <div class="settings-title">Settings</div>
      <button class="close-modal" onclick="toggleSettings()">&times;</button>
    </div>

    <div class="setting-section">
      <div class="setting-label">Algorithm Strategy</div>
      <select id="algoSelect" class="select-box" onchange="updateStats()">
        <option value="brute" selected>Force Brute Force (Exact, Slow)</option>
        <option value="auto">Auto (Switch at 150M Combos)</option>
        <option value="genetic">Force Genetic Algo (Approx, Fast)</option>
      </select>
    </div>
    
    <div class="setting-section">
      <div class="setting-label">Task Configuration (Name, Mins, Revenue)</div>
      <div id="ratesPanel" class="rate-rows-container">
        <!-- Injected JS -->
      </div>
    </div>

    <button class="btn-done" onclick="toggleSettings()">Done</button>
  </div>
</div>

<!-- WORKER SCRIPT: SMART PARALLEL SPLIT -->
<script id="worker-code" type="javascript/worker">
  self.onmessage = function(e) {
    try {
        const { mode, staffCount, taskConfig, targetMode } = e.data;
        const sCount = Number(staffCount); 
        
        // --- MODE 1: SMART BRUTE FORCE (Exact) ---
        if (mode === 'brute') {
          const { chunks, splitIdx, staticComps } = e.data; 
          
          let bestState = null;
          let bestMetric = { diff1: Infinity, diff2: Infinity };
          
          let d0, d1, d2, d3;
          
          // Reconstruct nested loops dynamically based on which index was split
          const assign = () => {
             let staticPtr = 0;
             d0 = (splitIdx === 0) ? chunks : staticComps[staticPtr++];
             d1 = (splitIdx === 1) ? chunks : staticComps[staticPtr++];
             d2 = (splitIdx === 2) ? chunks : staticComps[staticPtr++];
             d3 = (splitIdx === 3) ? chunks : staticComps[staticPtr++];
          }
          assign();

          const total = d0.length * d1.length * d2.length * d3.length;
          let processed = 0;
          const reportInterval = Math.max(1000, Math.floor(total / 20));

          const m0=taskConfig[0].min, v0=taskConfig[0].val;
          const m1=taskConfig[1].min, v1=taskConfig[1].val;
          const m2=taskConfig[2].min, v2=taskConfig[2].val;
          const m3=taskConfig[3].min, v3=taskConfig[3].val;

          // Optimization: Pre-allocate typed arrays for calculations
          let mins = new Float32Array(sCount);
          let revs = new Float32Array(sCount);

          for (let i0=0; i0<d0.length; i0++) {
            const r0 = d0[i0];
            for (let i1=0; i1<d1.length; i1++) {
              const r1 = d1[i1];
              for (let i2=0; i2<d2.length; i2++) {
                const r2 = d2[i2];
                for (let i3=0; i3<d3.length; i3++) {
                  const r3 = d3[i3];
                  
                  // Reset
                  // for(let k=0; k<sCount; k++) { mins[k]=0; revs[k]=0; } // Not needed as we overwrite

                  for(let s=0; s<sCount; s++) {
                      mins[s] = r0[s]*m0 + r1[s]*m1 + r2[s]*m2 + r3[s]*m3;
                      revs[s] = r0[s]*v0 + r1[s]*v1 + r2[s]*v2 + r3[s]*v3;
                  }

                  let minT=mins[0], maxT=mins[0], minR=revs[0], maxR=revs[0];
                  for(let s=1; s<sCount; s++) {
                      if(mins[s]<minT) minT=mins[s]; if(mins[s]>maxT) maxT=mins[s];
                      if(revs[s]<minR) minR=revs[s]; if(revs[s]>maxR) maxR=revs[s];
                  }

                  let dPri = targetMode === 'time' ? (maxT - minT) : (maxR - minR);
                  let dSec = targetMode === 'time' ? (maxR - minR) : (maxT - minT);

                  if (dPri < bestMetric.diff1 || (dPri === bestMetric.diff1 && dSec < bestMetric.diff2)) {
                      bestMetric = { diff1: dPri, diff2: dSec };
                      bestState = [r0, r1, r2, r3];
                  }

                  processed++;
                  if(processed % reportInterval === 0) self.postMessage({ type: 'progress', val: processed, total: total });
                }
              }
            }
          }
          self.postMessage({ type: 'done', bestState, bestMetric });
        } 
        
        // --- MODE 2: GENETIC ALGORITHM (Approx) ---
        else if (mode === 'genetic') {
           const { flatTasks, seed } = e.data;
           const POP_SIZE = 300; 
           const GENERATIONS = 800; 
           const ELITISM = 15;
           
           let population = [];
           for(let i=0; i<POP_SIZE; i++) {
               let genome = new Uint8Array(flatTasks.length);
               for(let j=0; j<flatTasks.length; j++) genome[j] = Math.floor(Math.random() * sCount);
               population.push(genome);
           }
           
           const calcFitness = (genome) => {
               let mins = new Float32Array(sCount);
               let revs = new Float32Array(sCount);
               for(let i=0; i<genome.length; i++) {
                   const s = genome[i]; const t = flatTasks[i];
                   mins[s] += t.min; revs[s] += t.val;
               }
               let minT=mins[0], maxT=mins[0], minR=revs[0], maxR=revs[0];
               for(let s=1; s<sCount; s++) {
                   if(mins[s]<minT) minT=mins[s]; if(mins[s]>maxT) maxT=mins[s];
                   if(revs[s]<minR) minR=revs[s]; if(revs[s]>maxR) maxR=revs[s];
               }
               const dPri = targetMode === 'time' ? (maxT - minT) : (maxR - minR);
               const dSec = targetMode === 'time' ? (maxR - minR) : (maxT - minT);
               return { genome, dPri, dSec };
           };

           for(let g=0; g<GENERATIONS; g++) {
               let scored = population.map(calcFitness);
               scored.sort((a,b) => (a.dPri !== b.dPri) ? a.dPri - b.dPri : a.dSec - b.dSec);
               
               if(g % 50 === 0) self.postMessage({ type: 'progress', val: g, total: GENERATIONS });

               let nextGen = [];
               for(let i=0; i<ELITISM; i++) nextGen.push(scored[i].genome);
               
               while(nextGen.length < POP_SIZE) {
                   const p1 = scored[Math.floor(Math.random()*60)].genome; // Top 20%
                   const p2 = scored[Math.floor(Math.random()*60)].genome;
                   let child = new Uint8Array(p1.length);
                   const cut = Math.floor(Math.random() * p1.length);
                   for(let k=0; k<p1.length; k++) child[k] = k < cut ? p1[k] : p2[k];
                   
                   if(Math.random() < 0.3) {
                       const idx = Math.floor(Math.random() * child.length);
                       child[idx] = Math.floor(Math.random() * sCount);
                   }
                   nextGen.push(child);
               }
               population = nextGen;
           }
           
           let best = calcFitness(population[0]);
           let counts = []; for(let s=0; s<sCount; s++) counts.push([0,0,0,0]);
           for(let i=0; i<best.genome.length; i++) counts[best.genome[i]][flatTasks[i].type]++;
           
           let bestState = [];
           for(let t=0; t<4; t++) {
               let col = []; for(let s=0; s<sCount; s++) col.push(counts[s][t]);
               bestState.push(col);
           }
           self.postMessage({ type: 'done', bestState, bestMetric: { diff1: best.dPri, diff2: best.dSec } });
        }
    } catch(err) {
        self.postMessage({ type: 'error', msg: err.message });
    }
  };
</script>

<script>
/* --- CONSTANTS & STATE --- */
const icons = {
  moon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`,
  sun: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`,
  lockOpen: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>`,
  lockClosed: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`,
  time: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`,
  cash: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"></rect><circle cx="12" cy="12" r="2"></circle><path d="M6 12h.01M18 12h.01"></path></svg>`,
  trash: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`,
  layers: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>`
};

const staffColors = ["#e07a5f", "#81b29a", "#a5a8c5", "#f2cc8f", "#7b8cde", "#dfa06e", "#6fab90"];

const toInt = v => { const n = parseInt(v); return isNaN(n)?0:n; }
const inputVal = id => toInt(document.getElementById(id).value);

let currentData = null; 
let combinedData = null; 
let locked = []; 
let staffCount = 0;
let distMode = 'time'; 
let sessionHistory = []; 
let activeWorkers = [];

const defaultTaskConfig = [
  { name: "90m", min: 90, val: 305 },
  { name: "60m Package", min: 60, val: 120 },
  { name: "60m Private (cardiac medium)", min: 60, val: 205 },
  { name: "15m", min: 15, val: 70 }
];

let taskConfig = JSON.parse(JSON.stringify(defaultTaskConfig));

/* --- INIT --- */
function initUI() {
  loadConfig();
  renderRatesPanel();
  renderTheme();
  renderMode();
  loadHistory();
}

function getCompositions(n, k) {
    if (k === 1) return [[n]];
    let results = [];
    for (let i = 0; i <= n; i++) {
        let rest = getCompositions(n - i, k - 1);
        for (let r of rest) results.push([i, ...r]);
    }
    return results;
}

const delay = ms => new Promise(res => setTimeout(res, ms));

function cancelCalculation() {
    activeWorkers.forEach(w => w.terminate());
    activeWorkers = [];
    document.getElementById('visModal').classList.remove('open');
}

function loadHistory() {
  if (sessionHistory.length === 0) {
      const stored = localStorage.getItem('workload_history');
      if (stored) {
          try { sessionHistory = JSON.parse(stored); } catch(e) { console.error(e); }
      }
  }

  const list = document.getElementById('historyList');
  const section = document.getElementById('historySection');
  
  if (sessionHistory.length === 0) {
      section.classList.remove('has-data');
      return;
  }
  
  section.classList.add('has-data');
  list.innerHTML = '';

  sessionHistory.forEach(rec => {
      const renderMiniGrid = (results) => {
          return results.map((s, idx) => {
               const color = staffColors[idx % staffColors.length];
               const h = (s.mins / 60);
               const hTxt = Number.isInteger(h) ? h : h.toFixed(1);
               const taskTxt = s.counts.map((c, k) => {
                   if (c === 0) return null;
                   const name = rec.config && rec.config[k] ? rec.config[k].name : taskConfig[k].name; 
                   return `${name}:${c}`;
               }).filter(Boolean).join(' â€¢ ');

               return `
               <div class="rec-staff-item" style="border-left: 3px solid ${color};">
                  <div class="rsi-name" style="color:${color}">Staff ${idx+1}</div>
                  <div class="rsi-stats">
                     <span class="rsi-time">${hTxt}h</span>
                     <span class="rsi-money">RM${s.rev}</span>
                  </div>
                  <div class="rsi-tasks">${taskTxt}</div>
               </div>`;
          }).join('');
      };

      const timeBadges = generateVarianceBadges(rec.resTime);
      const revBadges = generateVarianceBadges(rec.resRev);

      const card = `
        <div class="rec-card">
           <div class="rec-meta">
              <div class="rec-date">${rec.date} &bull; ${rec.staffCount} Staff</div>
              <button class="btn-del-rec" onclick="deleteRecord(${rec.id})">${icons.trash}</button>
           </div>
           
           <div class="rec-row-header">
              <div class="rec-row-label">${icons.time} Time Optimized</div>
              <div style="display:flex; gap:4px;">${timeBadges}</div>
           </div>
           <div class="rec-staff-grid" style="margin-bottom:16px;">
              ${renderMiniGrid(rec.resTime)}
           </div>

           <div class="rec-row-header">
              <div class="rec-row-label">${icons.cash} Revenue Optimized</div>
              <div style="display:flex; gap:4px;">${revBadges}</div>
           </div>
           <div class="rec-staff-grid">
              ${renderMiniGrid(rec.resRev)}
           </div>
        </div>
      `;
      list.innerHTML += card;
  });
}

/* --- THE HYBRID SOLVER ENGINE --- */
async function findBestDistribution(sCount, ins, targetMode, silent = false) {
    
    let complexity = 1;
    for(let i=0; i<4; i++) {
        if (ins[i] > 0) {
            let n = ins[i]; let k = sCount;
            let top = 1, bot = 1;
            for(let j=0; j<k-1; j++) { top *= (n+k-1-j); bot *= (j+1); }
            complexity *= (top/bot);
        }
    }
    
    const algoPref = document.getElementById('algoSelect').value;
    let USE_GENETIC = false;
    if (algoPref === 'genetic') USE_GENETIC = true;
    else if (algoPref === 'brute') USE_GENETIC = false;
    else USE_GENETIC = complexity > 15000000;

    if(!silent) {
      document.getElementById('visModal').classList.add('open');
      document.getElementById('visBar').style.width = "0%";
      if(USE_GENETIC) {
          document.getElementById('visStatus').innerText = "Running Genetic Evolution...";
          document.getElementById('visBest').innerText = "High Complexity Mode";
      } else {
          document.getElementById('visStatus').innerText = "Calculating Permutations...";
          document.getElementById('visBest').innerText = "Brute Force Mode";
      }
    }
    await delay(10);

    activeWorkers.forEach(w => w.terminate());
    activeWorkers = [];

    const concurrency = navigator.hardwareConcurrency || 4;
    const blob = new Blob([document.getElementById('worker-code').textContent], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(blob);
    
    let promises = [];
    
    if (USE_GENETIC) {
        let flatTasks = [];
        for(let i=0; i<4; i++) {
            for(let k=0; k<ins[i]; k++) flatTasks.push({ type: i, min: taskConfig[i].min, val: taskConfig[i].val });
        }

        for(let i=0; i<concurrency; i++) {
            const p = new Promise((resolve, reject) => {
                const w = new Worker(workerUrl);
                activeWorkers.push(w);
                w.onerror = e => { console.error(e); reject(new Error("Worker Crash")); };
                w.onmessage = e => {
                    if (e.data.type === 'error') reject(new Error(e.data.msg));
                    else if (e.data.type === 'progress' && !silent && i===0) {
                         const pct = ((e.data.val / e.data.total) * 100).toFixed(0);
                         document.getElementById('visBar').style.width = `${pct}%`;
                    } else if (e.data.type === 'done') resolve(e.data);
                };
                w.postMessage({ mode: 'genetic', staffCount: sCount, taskConfig, targetMode, flatTasks, seed: i });
            });
            promises.push(p);
        }

    } else {
        // --- SMART PARALLEL SPLIT ---
        // 1. Generate all base combinations
        const comps = [
            getCompositions(ins[0], sCount),
            getCompositions(ins[1], sCount),
            getCompositions(ins[2], sCount),
            getCompositions(ins[3], sCount)
        ];
        
        // 2. Find heaviest task to split
        let maxLen = -1, splitIdx = 0;
        comps.forEach((c, i) => { if(c.length > maxLen) { maxLen = c.length; splitIdx = i; } });
        
        // 3. Prepare chunks
        const splitArr = comps[splitIdx];
        const chunkSize = Math.ceil(splitArr.length / concurrency);
        
        // 4. Spawn Workers
        for(let i=0; i<concurrency; i++) {
            const start = i * chunkSize;
            const end = start + chunkSize;
            const chunk = splitArr.slice(start, end);
            if (chunk.length === 0) continue;

            let staticComps = [];
            comps.forEach((c, idx) => { if(idx !== splitIdx) staticComps.push(c); });

            const p = new Promise((resolve, reject) => {
                const w = new Worker(workerUrl);
                activeWorkers.push(w);
                w.onerror = e => { console.error(e); reject(new Error("Worker Crash")); };
                
                let currentProg = 0;
                w.onmessage = e => {
                    if (e.data.type === 'error') reject(new Error(e.data.msg));
                    else if (e.data.type === 'progress') {
                        currentProg = e.data.val;
                        if (!silent && i === 0) document.getElementById('visBar').style.width = `${(currentProg / (e.data.total) * 100).toFixed(0)}%`;
                    } else if (e.data.type === 'done') resolve(e.data);
                };
                
                w.postMessage({ mode: 'brute', staffCount: sCount, taskConfig, targetMode, chunks: chunk, splitIdx, staticComps });
            });
            promises.push(p);
        }
    }

    let results;
    try {
        results = await Promise.all(promises);
    } catch(e) {
        if(!silent) { alert(e.message); document.getElementById('visModal').classList.remove('open'); }
        return null;
    }

    let globalBest = { diff1: Infinity, diff2: Infinity }, bestState = null;
    results.forEach(res => {
        if (!res || !res.bestState) return;
        let isBetter = false;
        if (res.bestMetric.diff1 < globalBest.diff1) isBetter = true;
        else if (res.bestMetric.diff1 === globalBest.diff1 && res.bestMetric.diff2 < globalBest.diff2) isBetter = true;

        if (isBetter) { globalBest = res.bestMetric; bestState = res.bestState; }
    });

    if(!silent) document.getElementById('visModal').classList.remove('open');
    URL.revokeObjectURL(workerUrl);

    if (!bestState) return null;

    let result = [];
    for(let s=0; s<sCount; s++) {
        let counts = [bestState[0][s], bestState[1][s], bestState[2][s], bestState[3][s]];
        let m = 0, r = 0;
        counts.forEach((c, i) => { m += c * taskConfig[i].min; r += c * taskConfig[i].val; });
        result.push({ id: s, counts, revenue: r, minutes: m });
    }
    return result;
}

/* --- RECALC LOGIC --- */
async function recalculateUnlocked(){
  if (distMode === 'combined' || !currentData) return;
  
  let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));
  let held = [0,0,0,0];
  let lockedIndices = [];
  let activeIndices = [];

  for(let s=0; s<staffCount; s++) {
      if(locked[s]) {
          lockedIndices.push(s);
          for(let i=0; i<4; i++) held[i] += currentData.counts[s][i];
      } else {
          activeIndices.push(s);
      }
  }

  let remainder = [];
  for(let i=0; i<4; i++) {
      let r = ins[i] - held[i];
      if (r < 0) { alert("Locked values exceed total inputs."); return; }
      remainder.push(r);
  }

  const activeCount = activeIndices.length;
  if(activeCount === 0) { alert("All staff locked."); return; }

  const solution = await findBestDistribution(activeCount, remainder, distMode);

  if(!solution) return; 

  solution.forEach((res, idx) => {
      const realStaffIndex = activeIndices[idx]; 
      currentData.counts[realStaffIndex] = res.counts;
  });

  renderGrid();
}

/* --- UI HELPERS --- */
function toggleSettings() { document.getElementById('settingsModal').classList.toggle('open'); }
function toggleTheme() {
  const c = document.documentElement.getAttribute('data-theme');
  const n = c === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', n);
  localStorage.setItem('theme', n);
  renderTheme();
}
function renderTheme() {
  const t = localStorage.getItem('theme') || 'light';
  document.documentElement.setAttribute('data-theme', t);
  document.getElementById('themeBtn').innerHTML = t === 'dark' ? icons.sun : icons.moon;
}
function toggleMode() {
  if (distMode === 'time') distMode = 'revenue';
  else if (distMode === 'revenue') distMode = 'combined';
  else distMode = 'time';
  renderMode();
  if ((currentData || combinedData)) {
      if (distMode === 'combined') initialCalculate();
      else {
           if(locked.some(l => l) && distMode !== 'combined') recalculateUnlocked();
           else initialCalculate();
      }
  }
}
function renderMode() {
  const btn = document.getElementById('modeBtn');
  const lbl = document.getElementById('modeLabel');
  const body = document.body;
  body.classList.remove('mode-time', 'mode-revenue', 'mode-combined');
  body.classList.add(`mode-${distMode}`);
  
  if (distMode === 'time') {
    btn.innerHTML = `${icons.time} HOURS`; 
    btn.classList.add('active-time'); btn.classList.remove('active-rev', 'active-combined');
    lbl.innerHTML = `${icons.time} PRIORITY: HOURS`;
  } else if (distMode === 'revenue') {
    btn.innerHTML = `${icons.cash} REVENUE`; 
    btn.classList.add('active-rev'); btn.classList.remove('active-time', 'active-combined');
    lbl.innerHTML = `${icons.cash} PRIORITY: REVENUE`;
  } else {
    btn.innerHTML = `${icons.layers} COMBINED`; 
    btn.classList.add('active-combined'); btn.classList.remove('active-time', 'active-rev');
    lbl.innerHTML = `${icons.layers} PRIORITY: COMBINED`;
  }
}
function loadConfig() {
  const saved = localStorage.getItem('task_config');
  if(saved) {
    try {
      const parsed = JSON.parse(saved);
      taskConfig = defaultTaskConfig.map((def, i) => {
        const p = parsed[i] || {};
        return { name: p.name || def.name, min: p.min !== undefined ? p.min : def.min, val: p.val !== undefined ? p.val : def.val };
      });
    } catch(e) { taskConfig = JSON.parse(JSON.stringify(defaultTaskConfig)); }
  }
  updateInputLabels();
}
function saveConfig() {
  for(let i=0; i<4; i++) {
    taskConfig[i].name = document.getElementById(`cfg_name_${i}`).value || `Task ${i+1}`;
    taskConfig[i].min = toInt(document.getElementById(`cfg_min_${i}`).value);
    taskConfig[i].val = toInt(document.getElementById(`cfg_val_${i}`).value);
  }
  localStorage.setItem('task_config', JSON.stringify(taskConfig));
  updateInputLabels(); updateStats();
  if (currentData || combinedData) renderGrid();
}
function renderRatesPanel() {
  const container = document.getElementById('ratesPanel'); container.innerHTML = '';
  taskConfig.forEach((cfg, i) => {
    container.innerHTML += `<div class="rate-row"><input class="rate-name" type="text" id="cfg_name_${i}" value="${cfg.name}" placeholder="Name" oninput="saveConfig()"><div class="rate-input-group"><input class="rate-input" type="number" id="cfg_min_${i}" value="${cfg.min}" oninput="saveConfig()"><span>m</span></div><div class="rate-input-group"><input class="rate-input" type="number" id="cfg_val_${i}" value="${cfg.val}" oninput="saveConfig()"><span>RM</span></div></div>`;
  });
}
function updateInputLabels() {
  taskConfig.forEach((cfg, i) => { document.getElementById(`lbl_${i}`).innerText = `${cfg.name}`; });
}

function updateStats(){
  let count = 0; let hrs = 0;
  let complexity = 1;
  const sCount = Math.max(1, inputVal("totalStaff"));
  for(let i=0; i<4; i++) { 
    const qty = inputVal(`in_${i}`); 
    count += qty; 
    hrs += (qty * taskConfig[i].min); 
    if (qty > 0) {
       const n = qty; const k = sCount;
       let top = 1; let bot = 1;
       let limit = Math.min(k-1, n);
       for(let j=0; j<k-1; j++) { top *= (n+k-1-j); bot *= (j+1); }
       complexity *= (top/bot);
    }
  }
  hrs = hrs / 60;
  document.getElementById("valCount").innerText = count;
  document.getElementById("valHours").innerText = (Number.isInteger(hrs)?hrs:hrs.toFixed(1))+"h";

  let compStr = "-";
  if (count > 0) {
      if (complexity >= 1000000) compStr = (complexity / 1000000).toFixed(1) + "M";
      else if (complexity >= 1000) compStr = (complexity / 1000).toFixed(1) + "k";
      else compStr = Math.round(complexity);
  }
  document.getElementById("valComplexity").innerText = compStr;
}

async function saveDualRecord() {
    const btn = document.querySelector('.btn-save'); const originalText = btn.innerText;
    if(!currentData && !combinedData) { alert("Please distribute first."); return; }
    btn.innerText = "Saving..."; btn.disabled = true; await delay(50);
    try {
        const sCount = staffCount;
        let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));
        const resTime = await findBestDistribution(sCount, ins, 'time', true);
        const resRev = await findBestDistribution(sCount, ins, 'revenue', true);
        if (!resTime || !resRev || resTime.length === 0 || resRev.length === 0) throw new Error("Calculation failed");
        const mapRes = (r) => r.map(s => ({id:s.id+1, counts:s.counts, rev:s.revenue, mins:s.minutes}));
        const record = { id: Date.now(), date: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}), staffCount: sCount, config: JSON.parse(JSON.stringify(taskConfig)), resTime: mapRes(resTime), resRev: mapRes(resRev) };
        sessionHistory.unshift(record); 
        localStorage.setItem('workload_history', JSON.stringify(sessionHistory));
        loadHistory();
    } catch (e) { console.error(e); alert("Error saving: " + e.message); } finally { btn.innerText = originalText; btn.disabled = false; }
}

function deleteRecord(id) {
    sessionHistory = sessionHistory.filter(r => r.id !== id);
    localStorage.setItem('workload_history', JSON.stringify(sessionHistory));
    loadHistory();
}

async function initialCalculate(){
  staffCount = Math.max(1, inputVal("totalStaff"));
  let ins = []; for(let i=0; i<4; i++) ins.push(inputVal(`in_${i}`));
  const totalTasks = ins.reduce((a,b)=>a+b,0);
  if(staffCount<=0 || totalTasks===0) { alert("Please check inputs"); return; }
  
  if (distMode === 'combined') {
      const rTime = await findBestDistribution(staffCount, ins, 'time');
      const rRev = await findBestDistribution(staffCount, ins, 'revenue');
      if (!rTime || !rRev) return; 
      combinedData = { timeRes: rTime.map(s => ({...s, counts:[...s.counts]})), revRes: rRev.map(s => ({...s, counts:[...s.counts]})) };
      currentData = null; 
  } else {
      const bestResult = await findBestDistribution(staffCount, ins, distMode);
      if (!bestResult || bestResult.length === 0) return; 
      currentData = { counts: [] };
      bestResult.forEach(s => { currentData.counts.push([...s.counts]); });
      combinedData = null;
  }
  locked = new Array(staffCount).fill(false);
  renderGrid(); 
  document.getElementById("recalcBtn").style.display = "none";
}

function manualEdit(el){
  const staff = parseInt(el.getAttribute('data-staff')); 
  const idx = parseInt(el.getAttribute('data-idx'));
  const mode = el.getAttribute('data-mode');
  let val = parseInt(el.value); if(isNaN(val)) val = 0;
  if (distMode === 'combined') {
     if(mode === 'combined_t') combinedData.timeRes[staff].counts[idx] = val;
     if(mode === 'combined_r') combinedData.revRes[staff].counts[idx] = val;
     const recalc = (arr) => { let m=0, r=0; arr[staff].counts.forEach((c, k) => { m += c * taskConfig[k].min; r += c * taskConfig[k].val; }); arr[staff].minutes = m; arr[staff].revenue = r; }
     if(mode === 'combined_t') recalc(combinedData.timeRes); else recalc(combinedData.revRes);
  } else { currentData.counts[staff][idx] = val; }
  renderGrid();
}

function toggleLock(i){ 
    if(distMode === 'combined') return; 
    locked[i] = !locked[i]; 
    document.getElementById("recalcBtn").style.display = locked.some(x=>x) ? "flex" : "none"; 
    renderGrid(); 
}

function resetAll(){
  document.getElementById("totalStaff").value = "";
  for(let i=0; i<4; i++) document.getElementById(`in_${i}`).value = "";
  updateStats();
  document.getElementById("resultsContainer").innerHTML = `<div class="empty-state">Enter inputs to distribute workload...</div>`;
  currentData = null; combinedData = null; locked=[]; staffCount=0;
  document.getElementById("recalcBtn").style.display = "none";
}

function generateVarianceBadges(data) {
    if(!data || data.length === 0) return '';
    const mins = data.map(s => s.minutes || s.mins);
    const minT = Math.min(...mins); const maxT = Math.max(...mins);
    let tVar = minT > 0 ? (((maxT-minT)/minT)*100).toFixed(1) : "0.0";

    const revs = data.map(s => s.revenue || s.rev);
    const minRev = Math.min(...revs); const maxRev = Math.max(...revs);
    let revVar = minRev > 0 ? (((maxRev - minRev) / minRev) * 100).toFixed(1) : "0.0";

    return `<span class="var-badge ${parseFloat(tVar)<10?'ok':'warn'}">Time:${tVar}%</span><span class="var-badge ${parseFloat(revVar)<10?'ok':'warn'}">Rev:${revVar}%</span>`;
}

function renderGrid(){
  const grid = document.getElementById("resultsContainer"); grid.innerHTML = "";
  
  // -- COMBINED MODE --
  if (distMode === 'combined' && combinedData) {
      
      const renderSubGrid = (data, type) => {
          let html = "";
          data.forEach((staff, i) => {
             const c = staffColors[i % staffColors.length];
             let totalMins = 0; let totalRev = 0;
             staff.counts.forEach((cnt, idx) => { totalMins += cnt * taskConfig[idx].min; totalRev += cnt * taskConfig[idx].val; });
             const hrs = totalMins/60; const hrsTxt = Number.isInteger(hrs) ? hrs : hrs.toFixed(1);
             
             let tasksHTML = "";
             for(let k=0; k<4; k++) {
                const cnt = staff.counts[k]; const cssClass = cnt > 0 ? "" : "is-zero"; const label = taskConfig[k].name;
                tasksHTML += `<div class="task-row ${cssClass}"><span class="task-label">${label}</span><input class="task-input" type="number" data-staff="${i}" data-idx="${k}" data-mode="combined_${type==='HOURS'?'t':'r'}" value="${cnt}" oninput="manualEdit(this)"></div>`;
             }
             
             let heroHTML, subHTML;
             if(type === 'HOURS') { heroHTML = `${hrsTxt}<span>h</span>`; subHTML = `<span class="prefix">RM</span>${totalRev}`; }
             else { heroHTML = `<span class="prefix">RM</span>${totalRev}`; subHTML = `${hrsTxt}h`; }
             
             html += `<div class="staff-card"><div class="card-border-top" style="background:${c}"></div><div class="card-header"><div class="staff-name" style="color:${c}">Staff ${i+1}</div></div><div class="card-hero"><div class="hero-main">${heroHTML}</div><div class="hero-sub"><div class="hero-sec">${subHTML}</div></div></div><div class="card-tasks">${tasksHTML}</div></div>`;
          });
          return html;
      };

      grid.innerHTML = `
      <div class="split-grid-wrapper">
         <div class="grid-title">${icons.time} Optimized for HOURS <div style="margin-left:auto; display:flex; gap:6px;">${generateVarianceBadges(combinedData.timeRes)}</div></div>
         <div class="results-grid">${renderSubGrid(combinedData.timeRes, 'HOURS')}</div>
      </div>
      <div class="split-grid-wrapper" style="margin-top:12px;">
         <div class="grid-title">${icons.cash} Optimized for REVENUE <div style="margin-left:auto; display:flex; gap:6px;">${generateVarianceBadges(combinedData.revRes)}</div></div>
         <div class="results-grid">${renderSubGrid(combinedData.revRes, 'REVENUE')}</div>
      </div>`;
      return;
  }

  // -- SINGLE MODE --
  if (!currentData) return;

  grid.innerHTML = '<div class="split-grid-wrapper"><div class="grid-title">Results <div style="margin-left:auto; display:flex; gap:6px;">' + generateVarianceBadges(currentData.counts.map(c => {
      let m=0, r=0; c.forEach((x,i)=>{m+=x*taskConfig[i].min; r+=x*taskConfig[i].val}); return {mins:m, rev:r};
  })) + '</div></div><div class="results-grid"></div></div>';
  
  const gridEl = grid.querySelector('.results-grid');

  for(let i=0; i<staffCount; i++){
    const c = staffColors[i % staffColors.length]; const myCounts = currentData.counts[i];
    let totalMins = 0; let totalRev = 0;
    myCounts.forEach((cnt, idx) => { totalMins += cnt * taskConfig[idx].min; totalRev += cnt * taskConfig[idx].val; });
    const hrs = totalMins/60; const hrsTxt = Number.isInteger(hrs) ? hrs : hrs.toFixed(1);
    const isLocked = locked[i]; const lockClass = isLocked ? "locked" : ""; const lockIcon = isLocked ? icons.lockClosed : icons.lockOpen;
    
    let heroHTML, subHTML;
    if (distMode === 'time') { heroHTML = `${hrsTxt}<span>h</span>`; subHTML = `<span class="prefix">RM</span>${totalRev}`; } 
    else { heroHTML = `<span class="prefix">RM</span>${totalRev}`; subHTML = `${hrsTxt}h`; }
    
    let tasksHTML = "";
    for(let k=0; k<4; k++) {
        const cnt = myCounts[k]; const cssClass = cnt > 0 ? "" : "is-zero"; const label = taskConfig[k].name;
        tasksHTML += `<div class="task-row ${cssClass}"><span class="task-label">${label}</span><input class="task-input" type="number" data-staff="${i}" data-idx="${k}" value="${cnt}" oninput="manualEdit(this)"></div>`;
    }
    gridEl.innerHTML += `<div class="staff-card"><div class="card-border-top" style="background:${c}"></div><div class="card-header"><div class="staff-name" style="color:${c}">Staff ${i+1}</div><button class="lock-btn ${lockClass}" onclick="toggleLock(${i})" aria-label="Lock Staff">${lockIcon}</button></div><div class="card-hero"><div class="hero-main">${heroHTML}</div><div class="hero-sub"><div class="hero-sec">${subHTML}</div></div></div><div class="card-tasks">${tasksHTML}</div></div>`;
  }
}

initUI();
</script>
</body>
</html>
